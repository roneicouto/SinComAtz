<?xml version="1.0" standalone="yes"?>  <DATAPACKET Version="2.0"><METADATA><FIELDS><FIELD attrname="tipo" fieldtype="string" WIDTH="20"/><FIELD attrname="nome" fieldtype="bin.hex" SUBTYPE="Text"/><FIELD attrname="definicao" fieldtype="bin.hex" SUBTYPE="WideText"/></FIELDS><PARAMS CHANGE_LOG="1 0 4 2 0 4 3 0 4 4 0 4 5 0 4 6 0 4 7 0 4 8 0 4 9 0 4 10 0 4 11 0 4 12 0 4 13 0 4 14 0 4 15 0 4 16 0 4 17 0 4 18 0 4 19 0 4 20 0 4 21 0 4 22 0 4 23 0 4 24 0 4 25 0 4 26 0 4 27 0 4 28 0 4 29 0 4 30 0 4 31 0 4 32 0 4 33 0 4 34 0 4 35 0 4 36 0 4 37 0 4 38 0 4 39 0 4 40 0 4 41 0 4 42 0 4 43 0 4 44 0 4 45 0 4 46 0 4 47 0 4 48 0 4 49 0 4 50 0 4 51 0 4 52 0 4 53 0 4 54 0 4 55 0 4 56 0 4 57 0 4 58 0 4 59 0 4 60 0 4 61 0 4 62 0 4 63 0 4 64 0 4 65 0 4 66 0 4 67 0 4 68 0 4 69 0 4 70 0 4 71 0 4 72 0 4 73 0 4 74 0 4 75 0 4 76 0 4 77 0 4 78 0 4 79 0 4 80 0 4 81 0 4 82 0 4 83 0 4 84 0 4 85 0 4 86 0 4 87 0 4 88 0 4 89 0 4 90 0 4 91 0 4 92 0 4 93 0 4 94 0 4 95 0 4 96 0 4"/></METADATA><ROWDATA><ROW RowState="4" tipo="View" nome="vs_planopagamento" definicao="Create View vs_planopagamento&#013;&#010;&#009;&#009; as &#013;&#010; SELECT planopagto.codigo,&#010;    planopagto.descricao,&#010;    planopagto.sigla,&#010;    planopagto.pagamento,&#010;    abs(planopagto.nparc) AS nparc,&#010;    planopagto.privenc AS vencimentoprimeiraparcela,&#010;    planopagto.dias AS vencimentodemaisparcelas,&#010;    planopagto.comissao,&#010;    planopagto.tipocomis,&#010;    planopagto.taxaacres,&#010;    planopagto.encargo,&#010;    planopagto.inativo,&#010;    planopagto.altparc AS permitealterarquantparcela,&#010;    planopagto.periodo,&#010;    planopagto.idtabfin,&#010;    planopagto.limiteminimo_venda,&#010;    planopagto.permite_desconto,&#010;    planopagto.desconto_limite,&#010;    planopagto.permitealterarvalorparcela,&#010;    planopagto.limiteprimeirovencimento,&#010;    planopagto.limiteultimovencimento,&#010;    planopagto.obrigavalordeentrada,&#010;    planopagto.percentualmenorentrada&#010;   FROM planopagto;&#013;&#010;"/><ROW RowState="4" tipo="View" nome="vs_boletosbancarios" definicao="Create View vs_boletosbancarios&#013;&#010;&#009;&#009; as &#013;&#010; SELECT boletosgerados.codigoboleto,&#010;    boletosgerados.nossonumero,&#010;    boletosgerados.idcontareceber,&#010;    boletosgerados.codigoloja,&#010;    boletosgerados.cancelado,&#010;    boletosgerados.datacancelamento,&#010;    boletosgerados.codigocontabancaria,&#010;    boletosgerados.usuariocancelamento,&#010;    boletosgerados.usuarioinclusao,&#010;    boletosgerados.datainclusao,&#010;    boletosgerados.idnotavenda,&#010;    boletosgerados.codigobarras,&#010;    boletosgerados.linhadigitavel,&#010;    boletosgerados.vencimento,&#010;    boletosgerados.valorboleto,&#010;    boletosgerados.arquivo_impressao,&#010;    boletosgerados.carteira,&#010;    boletosgerados.mensagem_adicional,&#010;    boletosgerados.status,&#010;    boletosgerados.idultima_instrucaoremessa,&#010;    boletosgerados.idultima_instrucaoretorno,&#010;    contas.documento,&#010;    contas.clifor,&#010;    contas.valorsaldo,&#010;    contas.historico,&#010;    contas.baixa AS baixaconta,&#010;    contasbancarias.nome_agencia,&#010;    bancos.nome AS nomebanco,&#010;    (COALESCE(tipoinstrucaoretorno.finalizaprocesso, &apos;N&apos;::bpchar))::character(1) AS finalizaprocesso,&#010;    clientes.nome AS nomecliente,&#010;    ultimaremessa.dataocorrencia AS dataultimaremessa,&#010;    ultimoretorno.dataocorrencia AS dataultimoretorno&#010;   FROM ((((((((tab_boletosbancarios boletosgerados&#010;   JOIN contas ON (((contas.chave = boletosgerados.idcontareceber) AND (contas.filial = boletosgerados.codigoloja))))&#010;   JOIN tab_contasbancarias contasbancarias ON ((contasbancarias.codigocontabancaria = boletosgerados.codigocontabancaria)))&#010;   LEFT JOIN tab_boleto_instrucoesremessa ultimaremessa ON ((ultimaremessa.idinstrucaoremessa = boletosgerados.idultima_instrucaoremessa)))&#010;   LEFT JOIN tab_boleto_instrucoesretorno ultimoretorno ON ((ultimoretorno.idinstrucaoretorno = boletosgerados.idultima_instrucaoretorno)))&#010;   LEFT JOIN tab_boleto_tipoinstrucaoremessa tipoinstrucaoremessa ON (((tipoinstrucaoremessa.codigoinstrucaoremessa)::text = (ultimaremessa.codigoinstrucaoremessa)::text)))&#010;   LEFT JOIN tab_boleto_tipoinstrucaoretorno tipoinstrucaoretorno ON (((tipoinstrucaoretorno.codigoinstrucaoretorno)::text = (ultimoretorno.codigoinstrucaoretorno)::text)))&#010;   LEFT JOIN bancos_padrao bancos ON ((bancos.codigo = contasbancarias.codigobanco)))&#010;   LEFT JOIN clientes ON ((clientes.codigo = contas.clifor)));&#013;&#010;"/><ROW RowState="4" tipo="Sequence" nome="movim1_cce_idcce_seq" definicao="Create Sequence  movim1_cce_idcce_seq&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1"/><ROW RowState="4" tipo="Type" nome="tablefunc_crosstab_2" definicao="Create type tablefunc_crosstab_2 as &#013;&#010;&#009;&#009;(&#013;&#010;&#013;&#010;&#009;&#009;row_name text  ,&#013;&#010;&#009;&#009;category_1 text  ,&#013;&#010;&#009;&#009;category_2 text  &#013;&#010;&#009;&#009;)"/><ROW RowState="4" tipo="Sequence" nome="tab_boleto_instrucoesretorno_idinstrucaoretorno_seq" definicao="Create Sequence  tab_boleto_instrucoesretorno_idinstrucaoretorno_seq&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1"/><ROW RowState="4" tipo="Sequence" nome="movim2_controle_key" definicao="Create Sequence  movim2_controle_key&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1"/><ROW RowState="4" tipo="Sequence" nome="contagens_idcontagem_seq" definicao="Create Sequence  contagens_idcontagem_seq&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1"/><ROW RowState="4" tipo="Sequence" nome="logusuario_lanc_key" definicao="Create Sequence  logusuario_lanc_key&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1"/><ROW RowState="4" tipo="Sequence" nome="orcamentobalcao2_controle_seq" definicao="Create Sequence  orcamentobalcao2_controle_seq&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1"/><ROW RowState="4" tipo="View" nome="vs_balancoitens" definicao="Create View vs_balancoitens&#013;&#010;&#009;&#009; as &#013;&#010; SELECT balancos.codigobalanco,&#010;    balancos.codigoloja,&#010;    balancos.data_abertura,&#010;    p.descricao,&#010;    fabricantes.descricao AS marca_descricao,&#010;    p.complemento,&#010;    p.unidade AS unidadde_inteira,&#010;    p.unidfracao,&#010;    p.codbarra,&#010;    p.classific,&#010;    p.fornecedor,&#010;    p.fabrica,&#010;    p.idfamilia,&#010;    bitens.idbalancoitens,&#010;    bitens.idbalanco,&#010;    bitens.codigoproduto,&#010;    bitens.unidade,&#010;    bitens.fator,&#010;    bitens.quantidade,&#010;    bitens.identifica_grade,&#010;    bitens.situacao,&#010;    bitens.local_estoque,&#010;        CASE&#010;            WHEN (bitens.situacao = &apos;A&apos;::bpchar) THEN 1&#010;            ELSE 0&#010;        END AS marcado,&#010;    COALESCE(ppd.saldo, (0)::numeric) AS saldoanterior&#010;   FROM ((((balancoitens bitens&#010;   JOIN balancos ON ((balancos.idbalanco = bitens.idbalanco)))&#010;   JOIN estoque p ON ((p.codigo = bitens.codigoproduto)))&#010;   LEFT JOIN fabricantes ON ((fabricantes.codigo = p.fabrica)))&#010;   LEFT JOIN produtoposicaodiaria ppd ON ((((((ppd.idproduto = bitens.codigoproduto) AND (ppd.codigoloja = balancos.codigoloja)) AND (ppd.tipoestoque = bitens.local_estoque)) AND (ppd.idgrade = (bitens.identifica_grade)::bpchar)) AND (ppd.data = ( SELECT max(produtoposicaodiaria.data) AS max&#010;   FROM produtoposicaodiaria&#010;  WHERE (((((produtoposicaodiaria.data &lt; (balancos.data_abertura - 1)) AND (produtoposicaodiaria.idproduto = ppd.idproduto)) AND (produtoposicaodiaria.tipoestoque = ppd.tipoestoque)) AND (produtoposicaodiaria.codigoloja = ppd.codigoloja)) AND (produtoposicaodiaria.idgrade = ppd.idgrade)))))));&#013;&#010;"/><ROW RowState="4" tipo="Sequence" nome="balancocontagemitens_idcontagembalancoitens_seq" definicao="Create Sequence  balancocontagemitens_idcontagembalancoitens_seq&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1"/><ROW RowState="4" tipo="Function" nome="atualizaestoqfil()" definicao="CREATE OR REPLACE FUNCTION public.atualizaestoqfil()&#010; RETURNS void&#010; LANGUAGE plpgsql&#010;AS $function$&#010;DECLARE&#010;  codigo record;&#010;  codprodmax integer;&#010;  codprodmin integer;&#010;BEGIN&#010;&#009;codprodmax := (select max(estoque.codigo) from estoque &#010;&#009;&#009;&#009;&#009;&#009;where estoque.codigo not in (select produto from estoqfil));&#010;&#010;&#009;codprodmin := (select min(estoque.codigo) from estoque &#010;&#009;&#009;&#009;&#009;&#009;where estoque.codigo not in (select produto from estoqfil));&#010;&#010;&#009;for codigo in coalesce(codprodmin,0)..coalesce(codprodmax,0)&#010;&#009;loop&#010;&#009;&#009;--codprod := codigo;&#010;&#009;&#009;if codigo in (select estoque.codigo from estoque where &#010;&#009;estoque.codigo not in (select produto from estoqfil)) then&#010;&#009;&#009;insert into estoqfil(produto, filial) values (codigo,0);&#010;&#009;&#009;--return next codigo;&#010;&#009;&#009;--elseif codigo in (select * from estoque where estoque.codigo is null) then *CASO A LINHA DE PRODUTOS SEJA MIGRADA E VENHA COM REGISTROS NULOS&#010;&#009;&#009;end if;&#010;&#009;end loop; &#010;END;&#010;$function$&#010;"/><ROW RowState="4" tipo="Function" nome="trigger_ajusteestoque()" definicao="CREATE OR REPLACE FUNCTION public.trigger_ajusteestoque()&#010; RETURNS trigger&#010; LANGUAGE plpgsql&#010;AS $function$&#010;DECLARE &#010;&#009;REC RECORD;&#010;  ESTLOTES RECORD;&#010;  _fat integer; &#010;  Mov character(1);&#010;  Quant numeric(20,6);&#010;  _fator numeric;&#010;BEGIN&#010;&#009;IF TG_OP = &apos;INSERT&apos;   THEN&#010;            -- insere um novo registro no kardex, referente a entrada ou saida   &#010;            NEW.idkardex :=  nextval(&apos;kardex_idkardex_seq&apos;);&#010;             &#010;             select into rec * from estoque where codigo = new.produto; &#010;             quant := new.quantidade;    &#010;             if quant &gt; 0  THEN&#010;                _fat := 1;&#010;                 Mov := &apos;E&apos;;&#010;             ELSE&#010;                _fat := -1;&#010;                 Mov := &apos;S&apos;;&#010;            End If;&#010;            INSERT INTO&#010;               kardex&#010;                (&#010;                 idgrade,&#010;                 idkardex,&#010;                 idproduto,&#010;                 tipoestoque,&#010;                 codigoloja,&#010;                 data,&#010;                 tipo,&#010;                 es,&#010;                 unidade,&#010;                 fator,&#010;                 quantidade,&#010;                 descricao,&#010;                 codigousuario&#010;                ) &#010;                VALUES&#010;               ( &#010;                 coalesce(new.identifica_grade,&apos;&apos;),&#010;                 NEW.idkardex,&#010;                 new.produto,&#010;                 NEW.localestoque,&#010;                 new.filial,&#010;                 NEW.data,&#010;                 &apos;M&apos;,&#010;                 mov,&#010;                 case when coalesce(REC.fracao,&apos;&apos;) = &apos;S&apos; then rec.unidfracao else  rec.unidade end,&#010;                 1,&#010;                 abs(quant),&#010;                 &apos;Referente a ajuste de estoque&apos;,&#010;                 0&#010;&#010;                ) ;&#010;         If Coalesce(NEW.lote,&apos;&apos;) &lt;&gt; &apos;&apos; THEN&#010;            &#010;            --Testa se ja existe esse lote&#010;            &#010;            Select into ESTLOTES * from estoquelotes where idproduto = NEW.produto and idgrade = NEW.identifica_grade and lote = lote;&#010;            if ESTLOTES IS NULL THEN&#010;               -- insere lote novo &#010;               FOR ESTLOTES IN Insert into estoquelotes (idproduto,idgrade,lote,fabricacao,validade,saldo) values (NEW.produto,NEW.identifica_grade,NEW.lote,NEW.fabricacao,NEW.validade,(NEW.quantidade / NEW.fator) * _fat )  RETURNING idestoquelotes &#010;               loop&#010;                   NEW.idestoquelotes := ESTLOTES.idestoquelotes;&#010;               End Loop;&#010;            ELSE&#010;               -- Soma/Subtrai Estoque do registro novo &#010;               UPDATE estoquelotes Set saldo = saldo +  ( (NEW.quantidade / NEW.fator) * _fat ) where idproduto = NEW.produto and idgrade = NEW.identifica_grade and lote = lote;&#010;            End If;&#010;  &#009;     End if;&#010;         RETURN NEW;&#010;&#009; &#010; ELSEIF TG_OP = &apos;UPDATE&apos;&#009;THEN&#010;         &#010;             select into rec * from estoque where codigo = new.produto ;&#010;             quant := new.quantidade; &#010;             if quant &gt; 0  THEN&#010;                _fat := 1;&#010;                 Mov := &apos;E&apos;;&#010;             ELSE&#010;                _fat := -1;&#010;                 Mov := &apos;S&apos;;&#010;            End If;&#010;            -- altera registro no kardex, referente a entrada ou saida       &#010;            UPDATE &#010;               kardex&#010;                SET&#010;                (&#010;                 idgrade,&#010;                 idkardex,&#010;                 idproduto,&#010;                 tipoestoque,  &#010;                 codigoloja,&#010;                 data,&#010;                 tipo,&#010;                 es,&#010;                 unidade,&#010;                 fator,&#010;                 quantidade,&#010;                 descricao,&#010;                 codigousuario&#010;                ) &#010;                = &#010;               ( &#010;                 coalesce(new.identificagrade,&apos;&apos;),&#010;                 NEW.idkardex,&#010;                 new.produto,&#010;                 NEW.tipoestoque,&#010;                 NEW.filial,&#010;                 NEW.data,&#010;                 &apos;M&apos;,&#010;                 mov,&#010;                 case when  REC.fracao=&apos;S&apos; then rec.unidfracao else  rec.unidade end,&#010;                 1,&#010;                 abs(quant),&#010;                 &apos;Referente a ajuste de estoque&apos;,&#010;                 0&#010;&#010;&#010;                )   WHERE idkardex = old.idkardex;&#010;&#010;               If Coalesce(OLD.lote,&apos;&apos;) &lt;&gt; &apos;&apos; THEN&#010;                  -- Retira/Repoe Estoque do registro antigo &#010;                  UPDATE estoquelotes Set saldo = saldo +   (OLD.quantidade / OLD.fator) * ( _fat ) where idproduto = NEW.produto and idgrade = NEW.identifica_grade and lote = lote;&#010;               End If;     &#010;&#010;               If Coalesce(NEW.lote,&apos;&apos;) &lt;&gt; &apos;&apos; THEN&#010;                  &#010;                  Select into ESTLOTES * from estoquelotes where idproduto = NEW.produto and idgrade = NEW.identifica_grade and lote = lote;&#010;                  if ESTLOTES IS NULL THEN&#010;                     FOR ESTLOTES IN Insert into estoquelotes (idproduto,idgrade,lote, datafabricacao,datavalidade,saldo) values (NEW.produto,NEW.identifica_grade,NEW.lote,NEW.datafabricacao,NEW.datavalidade,(NEW.quantidade / NEW.fator) * _fat )  RETURNING idestoquelotes &#010;                     loop&#010;                       NEW.idestoquelotes := ESTLOTES.idestoquelotes;&#010;                     End Loop;&#010;                  ELSE&#010;                    -- Soma/Subtrai Estoque do registro novo &#010;                    UPDATE estoquelotes Set saldo = saldo +  (NEW.quantidade / NEW.fator) where idproduto = NEW.produto and idgrade = NEW.identifica_grade and lote = lote;&#010;                  End If;&#010;  &#010;       End if;&#010;&#009;&#010;&#009; RETURN NEW;&#010;END IF;&#010;IF TG_OP = &apos;DELETE&apos; and old.movimenta_estoque = &apos;S&apos; THEN&#010;    -- Retira/Repoe Estoque do registtro deletado &#010;    If Coalesce(OLD.lote,&apos;&apos;) &lt;&gt; &apos;&apos; THEN&#010;       UPDATE estoquelotes Set saldo = saldo +  ( (OLD.quantidade / OLD.fator) * ( _fat * -1 ) ) where idproduto = NEW.produto and idgrade = NEW.identifica_grade and lote = lote;&#010;    End If;     &#010;&#010;&#009;&#010;    -- apaga registro do kardex&#010;    Delete from kardex  where idkardex = old.idkardex; &#010;&#010;&#009;&#009;RETURN OLD;&#010;END IF;&#010;&#009;&#010;END;&#010;$function$&#010;"/><ROW RowState="4" tipo="Sequence" nome="produtoposicaodiaria_idprodutoposicaodiaria_seq" definicao="Create Sequence  produtoposicaodiaria_idprodutoposicaodiaria_seq&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1"/><ROW RowState="4" tipo="View" nome="vendas_itens" definicao="Create View vendas_itens&#013;&#010;&#009;&#009; as &#013;&#010; SELECT m2.link AS id_venda,&#010;    m2.filial AS id_filial,&#010;    m2.data,&#010;    m2.produto AS id_item,&#010;    e.descricao AS item_nome,&#010;    m2.complemento AS venda_item_complemento,&#010;    e.unidade AS item_unidade,&#010;    m2.quantidade,&#010;    m2.valor,&#010;    m2.desconto,&#010;    m2.acrescimo,&#010;    m2.icms AS venda_item_icms,&#010;    m2.redicms AS venda_item_redicms,&#010;    m2.ipi AS venda_item_ipi,&#010;    m2.baseicms_st,&#010;    m2.valoricms_st,&#010;    m2.redicms_st,&#010;    m2.fracao AS venda_fracao,&#010;    m2.fator AS venda_fracao_fator,&#010;    m2.cfop AS venda_item_cfop,&#010;    e.fornecedor AS id_fornecedor,&#010;    fornecedores.nome AS fornecedor_nome,&#010;    e.fabrica AS id_fabrica,&#010;    fabricantes.descricao AS fabrica_nome,&#010;    e.unidfracao,&#010;    e.idfamilia,&#010;    e.idtabtrib AS item_idtabtrib,&#010;    m1.clifor AS id_cliente,&#010;    clientes.nome AS cliente_nome,&#010;    clientes.endereco AS cliente_endereco,&#010;    clientes.bairro AS cliente_bairro,&#010;    clientes.cidade AS cliente_cidade,&#010;    clientes.uf AS cliente_uf,&#010;    clientes.cep AS cliente_cep,&#010;        CASE&#010;            WHEN ((clientes.tipo)::text = &apos;F&apos;::text) THEN clientes.cpf&#010;            ELSE clientes.cnpj&#010;        END AS cliente_cnpfcpf,&#010;        CASE&#010;            WHEN ((clientes.tipo)::text = &apos;F&apos;::text) THEN clientes.di&#010;            ELSE clientes.insc&#010;        END AS cliente_rg_iestadual,&#010;        CASE&#010;            WHEN (vendedor.apelido IS NULL) THEN vendedor.nome&#010;            ELSE vendedor.apelido&#010;        END AS vendedor_nome,&#010;    m1.datacanc&#010;   FROM ((((((movim2 m2&#010;   JOIN movim1 m1 ON (((m1.link = m2.link) AND (m1.filial = m2.filial))))&#010;   JOIN estoque e ON ((e.codigo = m2.produto)))&#010;   JOIN clientes ON ((clientes.codigo = m1.clifor)))&#010;   LEFT JOIN fabricantes ON ((fabricantes.codigo = e.fabrica)))&#010;   LEFT JOIN fornecedores ON ((fornecedores.codigo = e.fornecedor)))&#010;   LEFT JOIN vendedor ON ((vendedor.codigo = m1.vendedor)))&#010;  WHERE ((m1.mov)::text = &apos;4&apos;::text);&#013;&#010;"/><ROW RowState="4" tipo="Function" nome="script_create(character, character, character, boolean, character)" definicao="CREATE OR REPLACE FUNCTION public.script_create(pobjeto character, ptipo character, pschema character, patualizacao boolean, pscopo character)&#010; RETURNS text&#010; LANGUAGE plpgsql&#010;AS $function$ DECLARE &#010;      REC RECORD;&#010;      DESCRICAO Text;&#010;      Contador integer;&#010;      linguagem Text;&#010;&#010;&#010;BEGIN&#010;contador := 0;&#010;&#010;if ptipo = &apos;Table&apos; THEN&#010;   Descricao := &apos;Create table &apos; || case When pAtualizacao Then &apos;atualizacao.&apos; Else &#009;&apos;&apos; End || pobjeto ||chr(13) || chr(10) || &apos;&#009;&#009;&apos; || &apos;(&apos; || chr(13) || chr(10); &#010;   for REC IN&#010;&#009;&#009;&#009;&#009; Select&#010;&#009;&#009;&#009;&#009;&#009;&#009; nomecoluna column_name,&#010;&#009;&#009;&#009;&#009;&#009;&#009; formato tipo,&#010;&#009;&#009;&#009;&#009;&#009;&#009; aceitanulo,&#010;&#009;&#009;&#009;&#009;&#009;&#009; valordefault valor_default&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#010;&#009;&#009;&#009;&#009; from&#010;&#009;&#009;&#009;&#009;&#009;pg_class&#010;&#009;&#009;&#009;&#009;&#009; LEFT JOIN pg_catalog.pg_namespace n&#010;&#009;&#009;&#009;&#009;&#009; ON n.oid = pg_class.relnamespace&#010;&#009;&#009;&#009;&#009;&#009; JOIN atributos_colunas on idobjeto = pg_class.oid      &#010;&#009;&#009;&#009;&#009; where &#010;&#009;&#009;&#009;&#009;&#009; lower(nspname)=lower(pschema) and relname=pobjeto&#010;&#010;&#010;   Loop&#010;      Descricao := Descricao ||   case When contador &gt; 0 Then &apos;,&apos;  else &apos;&apos; End || chr(13) || chr(10)  || &apos;&#009;&#009;&apos; || Trim(Rec.column_name) || &apos; &apos; ||  Case When lower(REC.Valor_default) like &apos;%nextval%&apos; Then &apos; Serial &apos; else    Trim(REC.tipo) End || &apos;  &apos; || case When  not  REC.aceitanulo=&apos;YES&apos; Then &apos;Not Null&apos; else &apos;&apos; End ||  case When REC.Valor_default &lt;&gt; &apos;&apos; Then Case When lower(REC.Valor_default) like &apos;%nextval%&apos; Then &apos;  &apos; else &apos; Default &apos; ||  REC.valor_default  end else &apos;&apos; end ;&#010;      contador := 1;&#010;   End Loop;&#010;&#010;   Descricao := Descricao ||chr(13) || chr(10) || &apos;&#009;&#009;&apos; || &apos;)&apos;;&#010;   &#010; &#009;&#009;&#009;&#009;&#010;&#010;elseif pTipo =&apos;View&apos; Then&#010;   Descricao := &apos;Create View &apos; ||  pobjeto || chr(13) || chr(10) || &apos;&#009;&#009;&apos; || &apos; as &apos; || chr(13) || chr(10); &#010;   for REC IN&#010;    &#009; Select &#010;            view_definition &#010;       from &#010;          information_schema.views &#010;       where &#010;         table_name = pobjeto  and table_schema = pSchema&#010;   Loop&#010;      contador := 1;&#010;      Descricao := Descricao ||   REC.view_definition || chr(13) || chr(10) ;&#010;   End Loop;&#010;&#010;elseif pTipo =&apos;Sequence&apos; Then&#010;&#010;   Descricao := &apos;Create Sequence  &apos; || pobjeto || chr(13) || chr(10); &#010;   for REC IN&#010;    &#009; Select &#010;            * &#010;       from &#010;          information_schema.sequences&#010;       where &#010;         sequence_name = pobjeto and sequence_schema = pschema&#010;   Loop&#010;      contador := 1;&#010;  &#010;      Descricao := Descricao ||   &apos; INCREMENT &apos; || REC.increment || &apos; MINVALUE &apos; || REC.minimum_value || &apos; MAXVALUE &apos; || REC.maximum_value || &apos; START &apos; || REC.start_value;&#010;   End Loop;&#010;&#010;elseif pTipo like  &apos;%Function%&apos; Then&#010;&#010;&#010;&#010;    select into  rec pg_get_functiondef(p.oid) definicao from pg_proc  p  LEFT JOIN pg_namespace n ON  n.oid = pronamespace where quote_ident(proname) || &apos;(&apos; || oidvectortypes(proargtypes)&#010;                || &apos;)&apos;  =  pobjeto and  nspname = pschema;&#010;&#010;   &#010;    Descricao := &apos;&apos;;&#010;&#010;   if found Then&#010;      contador := 1;&#010;      Descricao := REC.definicao; &#010;    End If;&#010;  &#010;&#010;    &#010;   &#010;&#010;Elseif ptipo = &apos;Type&apos; THEN&#010;   Descricao := &apos;Create type &apos;  || pobjeto || &apos; as &apos;  ||chr(13) || chr(10) || &apos;&#009;&#009;&apos; || &apos;(&apos; || chr(13) || chr(10); &#010;    for REC IN&#010;       Select&#010;           nomecoluna column_name,&#010;           formato tipo,&#010;           aceitanulo,&#010;           valordefault valor_default&#010;            &#010;       from&#010;        pg_class&#010;         LEFT JOIN pg_catalog.pg_namespace n&#010;         ON n.oid = pg_class.relnamespace&#010;         LEFT JOIN atributos_colunas on idobjeto = pg_class.oid      &#010;       where &#010;         lower(nspname)=lower(pschema) and relname=pobjeto&#010;&#010;   Loop&#010;      Descricao := Descricao ||   case When contador &gt; 0 Then &apos;,&apos;  else &apos;&apos; End || chr(13) || chr(10)  || &apos;&#009;&#009;&apos; || Trim(Rec.column_name) || &apos; &apos; ||  Case When lower(REC.Valor_default) like &apos;%nextval%&apos; Then &apos; Serial &apos; else    Trim(REC.tipo) End || &apos;  &apos; || case When  not  REC.aceitanulo=&apos;YES&apos; Then &apos;Not Null&apos; else &apos;&apos; End ||  case When REC.Valor_default &lt;&gt; &apos;&apos; Then Case When lower(REC.Valor_default) like &apos;%nextval%&apos; Then &apos;  &apos; else &apos; Default &apos; ||  REC.valor_default  end else &apos;&apos; end ;&#010;      contador := 1;&#010;   End Loop;&#010;&#010;   Descricao := Descricao ||chr(13) || chr(10) || &apos;&#009;&#009;&apos; || &apos;)&apos;;&#010;  &#010;&#010;End If;&#010;  if contador = 0 THEN &#010;      Descricao := &apos;&apos;;&#010;  End If;  &#010;  Return Descricao;&#010;END&#010;$function$&#010;"/><ROW RowState="4" tipo="Sequence" nome="contas_chave_key" definicao="Create Sequence  contas_chave_key&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 100527"/><ROW RowState="4" tipo="View" nome="ver_planocta_pai" definicao="Create View ver_planocta_pai&#013;&#010;&#009;&#009; as &#013;&#010; SELECT planodecontas.codigo_conta,&#010;    planodecontas.nivelconta,&#010;        CASE&#010;            WHEN ((planodecontas.nivelconta)::bpchar = &apos;2&apos;::bpchar) THEN &quot;substring&quot;((planodecontas.codigo_conta)::text, 1, 1)&#010;            ELSE&#010;            CASE&#010;                WHEN ((planodecontas.nivelconta)::bpchar = &apos;3&apos;::bpchar) THEN &quot;substring&quot;((planodecontas.codigo_conta)::text, 1, 3)&#010;                ELSE&#010;                CASE&#010;                    WHEN ((planodecontas.nivelconta)::bpchar = &apos;4&apos;::bpchar) THEN &quot;substring&quot;((planodecontas.codigo_conta)::text, 1, 5)&#010;                    ELSE&#010;                    CASE&#010;                        WHEN ((planodecontas.nivelconta)::bpchar = &apos;5&apos;::bpchar) THEN &quot;substring&quot;((planodecontas.codigo_conta)::text, 1, 7)&#010;                        ELSE NULL::text&#010;                    END&#010;                END&#010;            END&#010;        END AS contapai&#010;   FROM planodecontas;&#013;&#010;"/><ROW RowState="4" tipo="Sequence" nome="balancos_idbalanco_seq" definicao="Create Sequence  balancos_idbalanco_seq&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1"/><ROW RowState="4" tipo="Type" nome="tablefunc_crosstab_3" definicao="Create type tablefunc_crosstab_3 as &#013;&#010;&#009;&#009;(&#013;&#010;&#013;&#010;&#009;&#009;row_name text  ,&#013;&#010;&#009;&#009;category_1 text  ,&#013;&#010;&#009;&#009;category_2 text  ,&#013;&#010;&#009;&#009;category_3 text  &#013;&#010;&#009;&#009;)"/><ROW RowState="4" tipo="Function" nome="trigger_novoestoquegrade()" definicao="CREATE OR REPLACE FUNCTION public.trigger_novoestoquegrade()&#010; RETURNS trigger&#010; LANGUAGE plpgsql&#010;AS $function$&#010;DECLARE &#010;   vEstoqFil record;&#010;   --grades record;&#010;   &#010;   somaEstoqueGrade double precision;&#010;   BEGIN&#010;     select into vEstoqfil produto, filial from estoqfil where produto=new.idproduto and filial=new.idfilial;&#010;     if vEstoqFil is null then&#010;        insert into estoqfil (produto, filial, estreal, estfiscal) values (new.idproduto, new.idfilial, coalesce(new.loja, 0), coalesce(new.deposito, 0) );   &#010;     end if;&#010;     &#010;     return new; &#010;/*     somaEstoqueGrade := new.loja;&#010;     for in grades select * from grades_estoque where idproduto=new.idproduto and idfilial=new.idfilial and identificagrade &lt;&gt; newidentificagrade&#010;     loop&#010;        somaEstoqueGrade := somaEstoqueGrade + new.loja&#010;     end loop;&#010;       update */&#010;   END;&#010;$function$&#010;"/><ROW RowState="4" tipo="Function" nome="fprodutoembalanco(bigint, bigint, character, character)" definicao="CREATE OR REPLACE FUNCTION public.fprodutoembalanco(pcodigoloja bigint, pcodigoproduto bigint, pidentifica_grade character, plocal_estoque character)&#010; RETURNS boolean&#010; LANGUAGE plpgsql&#010;AS $function$DECLARE&#010;REC RECORD;&#010;BEGIN&#010;      select into Rec * from balancoitens  left join balancos on balancos.idbalanco = balancoitens.idbalanco  &#010;            where balancos.codigoloja = pcodigoloja and ( Coalesce(balancos.situacao,&apos;A&apos;) = &apos;A&apos;  or Coalesce(balancoitens.situacao,&apos;A&apos;) = &apos;A&apos;) and&#010;            balancos.local_estoque = plocal_estoque and codigoproduto = pcodigoproduto and Coalesce(identifica_grade,&apos;&apos;)=Coalesce(pidentifica_grade,&apos;&apos;);&#010;            If rec.codigoproduto = pcodigoproduto Then&#010;              Return true;&#010;            else&#010;              Return False; &#010;            End If;   &#010;&#010;&#009;--Routine body goes here...&#010;  select &#010;&#009;RETURN &apos;NULL&apos;;&#010;END&#010;$function$&#010;"/><ROW RowState="4" tipo="Function" nome="trigger_balancoitens()" definicao="CREATE OR REPLACE FUNCTION public.trigger_balancoitens()&#010; RETURNS trigger&#010; LANGUAGE plpgsql&#010;AS $function$&#010;   DECLARE &#010;      est FLOAT; &#010;      rec record;&#010;      --lotes record;&#010;      rec2 record;&#010;      rec3 record;&#010;&#010;BEGIN&#010;&#010;   IF TG_OP = &apos;UPDATE&apos; Then&#009;&#010;       -- raise notice &apos;Processando produto %, estoque %       %&apos;, new.descricao, new.quantidade, CURRENT_TIME;&#010;&#010;         if OLD.situacao = &apos;A&apos; and NEW.situacao &lt;&gt; &apos;A&apos; THEN&#010;           -- if NEW.identifica_grade&lt;&gt;&apos;040101&apos; then       &#010;           -- raise exception &apos; produto  %    grade %   quant = % &apos;, NEW.codigoproduto, NEW.identifica_grade, new.quantidade;      &#010;           -- end if;&#010;            Select into est atualizaposicaoestoque(NEW.data_abertura, NEW.codigoproduto, NEW.identifica_grade, NEW.local_estoque, NEW.CodigoLoja, NEW.quantidade, &apos;C&apos;);&#010;&#010;            --Zera estoque dos lotes nao informados na contagem&#010;        /*    for  rec2 in select * from  estoquelotes  where (codigoproduto,COALESCE(IdItensgrade,0),idarmazem) =  ( NEW.codigoproduto,COALESCE(new.gradeproduto,0),NEW.idarmazem) &#010;            Loop&#010;              Select into rec3  atualizaposicaolote(NEW.data_abertura, rec2.lote, id_produtoarmazem,rec2.iditensgrade, 0, &apos;C&apos;);  &#010;            End Loop;&#010;&#010;&#010;            for  lotes in select * from balancoitenslotes where balancoitenslotes.idbalancoitens = NEW.idbalancoitens&#010;            loop&#010;                for rec2 in &#010;&#009;&#009;&#009;insert into vs_movimentacaolotes&#010;&#009;&#009;&#009; (&#010;&#009;&#009;&#009;&#009;idmovimentacaolotes,&#010;&#009;&#009;&#009;&#009;tipo, &#010;&#009;&#009;&#009;&#009;es, &#010;&#009;&#009;&#009;&#009;idarmazem,&#010;&#009;&#009;&#009;&#009;iditensgrade,&#010;&#009;&#009;&#009;&#009;idmovimentacao, &#010;&#009;&#009;&#009;&#009;siglaunidade, &#010;&#009;&#009;&#009;&#009;fator, &#010;&#009;&#009;&#009;&#009;data, &#010;&#009;&#009;&#009;&#009;codigousuario, &#010;&#009;&#009;&#009;&#009;quantidade, &#010;&#009;&#009;&#009;&#009;idestoquelotes, &#010;&#009;&#009;&#009;&#009;codigoproduto, &#010;&#009;&#009;&#009;&#009;lote, &#010;&#009;&#009;&#009;&#009;fabricacao, &#010;&#009;&#009;&#009;&#009;validade, &#010;&#009;&#009;&#009;&#009;codigoloja&#010;&#009;&#009;&#009; )&#010;&#009;&#009;&#009; values &#010;&#009;&#009;&#009; (&#010;&#009;&#009;&#009;&#009;null,&#010;&#009;&#009;&#009;&#009;&apos;C&apos;, &#010;&#009;&#009;&#009;&#009;&apos;E&apos;, &#010;&#009;&#009;&#009;&#009;NEW.idarmazem,&#010;&#009;&#009;&#009;&#009;NEW.gradeproduto, &#010;&#009;&#009;&#009;&#009;null, &#010;&#009;&#009;&#009;&#009;NEW.unidade, &#010;&#009;&#009;&#009;&#009;NEW.fator, &#010;&#009;&#009;&#009;&#009;NEW.data_abertura,&#010;&#009;&#009;&#009;&#009;NEW.codigousuario, &#010;&#009;&#009;&#009;&#009;lotes.quantidade, &#010;&#009;&#009;&#009;&#009;null, &#010;&#009;&#009;&#009;&#009;NEW.codigoproduto, &#010;&#009;&#009;&#009;&#009;lotes.lote, &#010;&#009;&#009;&#009;&#009;lotes.fabricacao, &#010;&#009;&#009;&#009;&#009;lotes.validade, &#010;&#009;&#009;&#009;&#009;rec.filial&#010;&#009;&#009;&#009; ) returning idmovimentacaolotes&#010;                loop&#010;                    update balancoitenslotes set idmovimentacaolotes = rec2.idmovimentacaolotes where  (idbalancoitens,lote) = (lotes.idbalancoitens,lotes.lote);&#010;                End Loop;  &#010;            end loop; */&#010;            &#010;         ElseIf OLD.situacao &lt;&gt; &apos;A&apos; and NEW.situacao = &apos;A&apos; THEN&#010;           -- raise exception &apos;Desfaz Processar - situacao %&apos;, NEW.situacao;  &#009;&#010;            Select into est  atualizaposicaoestoque(NEW.data_abertura, NEW.codigoproduto, NEW.identifica_grade, NEW.local_estoque, NEW.CodigoLoja, 0, &apos;D&apos;);      &#010;&#009;&#009;&#009;     &#010;            --Volta os estoque dos lotes zerados na processamento do balancocontagens&#010;           /* for  rec2 in select * from  loteposicaodiaria  where  (idprodutoarmazens,COALESCE(IdItensgrade,0),data) =  ( id_produtoarmazem,COALESCE(new.gradeproduto,0),NEW.data_abertura) and Coalesce(Balanco,false)&#010;            Loop&#010;                select into rec atualizaposicaolote(rec2.data, rec2.lote, rec2.idprodutoarmazens,rec2.iditensgrade, 0, &apos;D&apos;);  &#010;            End Loop;&#010;&#010;            for  lotes in select * from balancoitenslotes where balancoitenslotes.idbalancoitens = NEW.idbalancoitens&#010;            loop&#010;              update balancoitenslotes set idmovimentacaolotes = null where (idbalancoitens,lote) = (lotes.idbalancoitens,lotes.lote);&#010;              delete from vs_movimentacaolotes where idmovimentacaolotes = lotes.idmovimentacaolotes;&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#010;            end loop;*/&#010;         End if;&#010;&#010;         UPDATE balancoitens SET situacao = NEW.situacao where idbalancoitens = NEW.idbalancoitens;&#010;         --RAISE notice &apos;Processado produto    %&apos;,CURRENT_TIME;&#010;&#010;         RETURN NEW;&#010;    &#010;      END IF;&#010;     &#010;    END;&#010;$function$&#010;"/><ROW RowState="4" tipo="Sequence" nome="tab_boletosbancarios_codigoboleto_seq" definicao="Create Sequence  tab_boletosbancarios_codigoboleto_seq&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1"/><ROW RowState="4" tipo="Function" nome="festoquegradecriaregistro(integer, integer, text)" definicao="CREATE OR REPLACE FUNCTION public.festoquegradecriaregistro(pcodigoloja integer, pcodigoproduto integer, pidentifica_grade text)&#010; RETURNS void&#010; LANGUAGE plpgsql&#010;AS $function$&#010; DECLARE &#010;   REC RECORD;&#010;BEGIN&#010;   SELECT INTO REC &#010;      * &#010;   FROM&#010;&#009;grade_estoque &#010;   WHERE&#010;&#009;idproduto = pCodigoProduto and identifica_grade = pIdentifica_grade and idfilial=pCodigoLoja;&#010;&#010;   IF Rec is null THEN&#010;      Insert into grade_estoque &#010;      (&#010;&#009;idproduto,&#010;&#009;idfilial,&#010;&#009;identifica_grade,&#010;&#009;loja,&#010;&#009;deposito&#010;      ) &#010;&#009;values &#010;      (&#010;&#009;pCodigoProduto,&#009;&#010;&#009;pCodigoLoja,&#010;&#009;pIdentifica_grade,&#010;&#009;0,&#010;&#009;0&#010;      );&#009;&#009;&#009;   &#010;   END IF;&#010;   &#010;   RETURN;&#010;END;&#010;&#010;$function$&#010;"/><ROW RowState="4" tipo="Function" nome="insertupdate(text, text, text, text)" definicao="CREATE OR REPLACE FUNCTION public.insertupdate(tabela text, campos text, valores text, condicao text)&#010; RETURNS void&#010; LANGUAGE plpgsql&#010;AS $function$&#010;DECLARE r integer;&#010;BEGIN&#010;    EXECUTE &apos;UPDATE &apos; || tabela || &apos; SET &apos; || campos || &apos; = &apos; || valores || &apos; WHERE &apos; || condicao ;&#010;    GET DIAGNOSTICS r = ROW_COUNT;&#010;    IF r = 0 THEN&#010;        EXECUTE &apos;INSERT INTO &apos; || tabela || &apos; &apos; || campos || &apos; VALUES &apos; || valores ;&#010;    END IF;&#010;    RETURN;&#010;END;&#010;&#010;$function$&#010;"/><ROW RowState="4" tipo="Type" nome="tablefunc_crosstab_4" definicao="Create type tablefunc_crosstab_4 as &#013;&#010;&#009;&#009;(&#013;&#010;&#013;&#010;&#009;&#009;row_name text  ,&#013;&#010;&#009;&#009;category_1 text  ,&#013;&#010;&#009;&#009;category_2 text  ,&#013;&#010;&#009;&#009;category_3 text  ,&#013;&#010;&#009;&#009;category_4 text  &#013;&#010;&#009;&#009;)"/><ROW RowState="4" tipo="Function" nome="compara_estrutura(character, character, character, character)" definicao="CREATE OR REPLACE FUNCTION public.compara_estrutura(pschemaorigem character, ptabelaorigem character, pschemadestino character, ptabeladestino character)&#010; RETURNS text&#010; LANGUAGE plpgsql&#010;AS $function$DECLARE&#010;  TabelaOrigem    record;&#010;  TabelaDestino   record;&#010;  Retorno Text;&#010;  retorno2 Text;&#010;contador integer;&#010; &#010;  r text; &#010;begin &#010;&#010; Retorno := &apos;&apos;;&#010;&#010;    Select into TabelaOrigem &#010;            *            &#010;       from&#010;          pg_class&#010;          LEFT JOIN pg_catalog.pg_namespace n&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009; ON n.oid = pg_class.relnamespace&#010;       where &#010;        (lower(nspname),lower(relname))=(lower(pschemadestino),lower(ptabeladestino));&#010;  if not found THEN&#010;&#010;     Retorno := script_create(pTabelaOrigem, &apos;Table&apos;, pschemaorigem,false,&apos;&apos;);&#010;     Retorno := replace(Retorno,  &apos;Create &apos; || ptabeladestino , &apos;Create &apos; ||    pschemadestino  || &apos;.&apos; || ptabeladestino );&#010;  Else&#010;&#010;&#009;&#009;&#009;&#009;contador := 0;&#010;        retorno2 := &apos;&apos;;&#010;&#009;&#009;&#009;&#009;for TabelaOrigem IN&#010;&#009;&#009;&#009;&#009;&#009;&#009; Select&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;nomecoluna column_name,&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009; formato tipo,&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009; aceitanulo,&#010;&#009;                 replace(valordefault,&apos;atualizacao.&apos;,&apos;&apos;)  valor_default&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;--&#009;case When lower(valordefault) like &apos;nextval%&apos; Then &apos;&apos; else valordefault end valor_default&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#010;&#009;&#009;&#009;&#009;&#009;&#009; from&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;pg_class&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009; LEFT JOIN pg_catalog.pg_namespace n&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009; ON n.oid = pg_class.relnamespace&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009; LEFT JOIN atributos_colunas on idobjeto = pg_class.oid      &#010;&#009;&#009;&#009;&#009;&#009;&#009; where &#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009; (lower(nspname),lower(relname))=(lower(pschemaorigem),lower(ptabelaorigem))&#010;&#009;&#009;&#009;&#009; loop&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009; Select into TabelaDestino &#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009; nomecoluna column_name,&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009; formato tipo,&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009; aceitanulo,&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009; &#009;valordefault  valor_default&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009; from&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;pg_class&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009; LEFT JOIN pg_catalog.pg_namespace n&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009; ON n.oid = pg_class.relnamespace&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009; LEFT JOIN atributos_colunas on idobjeto = pg_class.oid      &#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009; where &#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009; (lower(nspname),lower(relname), nomecoluna)=(lower(pschemadestino),lower(ptabeladestino),TabelaOrigem.column_name);&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009; &#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009; if Found THEN&#010;&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;if (TabelaOrigem.tipo,TabelaOrigem.aceitanulo,Coalesce(TabelaOrigem.valor_default,&apos;semvalor&apos;) ) &lt;&gt;  (TabelaDestino.tipo,TabelaDestino.aceitanulo,Coalesce(TabelaDestino.valor_default ,&apos;semvalor&apos;)) THEN&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#010;                      if   Tabeladestino.aceitanulo  and not TabelaOrigem.aceitanulo THEN&#010;                          &#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;case Trim(Left(TabelaDestino.tipo,7))  &#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;When  &#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&apos;real&apos;,&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&apos;numeric&apos;,&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&apos;bigint&apos;,&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&apos;oid&apos;,&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&apos;smallint&apos;,&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&apos;double precision&apos;&#010;&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;THEN&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009; retorno2 := retorno2 || case When contador = 0 Then   &apos; set &apos; else &apos;,&apos; end || TabelaDestino.column_name  || &#010;                                  case When  Coalesce(TabelaOrigem.valor_default,&apos;semvalor&apos;) &lt;&gt; &apos;semvalor&apos; Then &apos; = &apos; || TabelaOrigem.valor_default Else &apos; = 0&apos; End;&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;WHEN &#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&apos;real[]&apos;,&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&apos;numeric[]&apos;,&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&apos;bigint[]&apos;,&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&apos;oid[]&apos;,&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&apos;smallint[]&apos;,&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&apos;double precision[]&apos;&#010;&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;THEN&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009; retorno2 := retorno2 ||  case When contador = 0 Then   &apos; set &apos; else &apos;,&apos; end || TabelaDestino.column_name  || &#010;                                   case When  Coalesce(TabelaOrigem.valor_default,&apos;semvalor&apos;) &lt;&gt; &apos;semvalor&apos; Then &apos; = &apos; || TabelaOrigem.valor_default Else &apos; = &apos; || &apos;&apos;&apos;{0}&apos;&apos;&apos; end;&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;WHEN &#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&apos;date&apos;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;THEN&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009; retorno2 := retorno2 || case When contador = 0 Then   &apos; set &apos; else &apos;,&apos; end || TabelaDestino.column_name  ||&#010;                                   case When  Coalesce(TabelaOrigem.valor_default,&apos;semvalor&apos;) &lt;&gt; &apos;semvalor&apos; Then &apos; = &apos; || TabelaOrigem.valor_default Else &apos; = &apos; || &apos;&apos;&apos;19000101&apos;&apos;&apos; end;   &#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;WHEN &#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&apos;date[]&apos;&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;THEN&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009; retorno2 := retorno2 ||  case When contador = 0 Then   &apos; set &apos; else &apos;,&apos; end || TabelaDestino.column_name  || &apos; = &apos; || &apos;&apos;&apos;{19000101}&apos;&apos;&apos;;   &#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;WHEN &#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&apos;boolean&apos;&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;THEN&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009; retorno2 := retorno2 ||  case When contador = 0 Then   &apos; set &apos; else &apos;,&apos; end || TabelaDestino.column_name  || &apos; =  false&apos;;   &#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;WHEN &#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&apos;boolean[]&apos;&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;THEN&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009; retorno2 := retorno2 || case When contador = 0 Then   &apos; set &apos; else &apos;,&apos; end || TabelaDestino.column_name  ||&#010;                                   case When  Coalesce(TabelaOrigem.valor_default,&apos;semvalor&apos;) &lt;&gt; &apos;semvalor&apos; Then &apos; = &apos; || TabelaOrigem.valor_default Else &apos; = &apos; || &apos;&apos;&apos;{false}&apos;&apos;&apos; end;   &#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;ELSE&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009; if TabelaDestino.tipo like &apos;%[]%&apos; THEN&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;retorno2 := retorno2 ||  case When contador = 0 Then   &apos; set &apos; else &apos;,&apos; end || TabelaDestino.column_name  ||&#010;                                   case When  Coalesce(TabelaOrigem.valor_default,&apos;semvalor&apos;) &lt;&gt; &apos;semvalor&apos; Then &apos; = &apos; || TabelaOrigem.valor_default Else &apos; = &apos; || &apos;&apos;&apos;{}&apos;&apos;&apos; end;   &#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009; ELSE&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;retorno2 := retorno2 ||  case When contador = 0 Then   &apos; set &apos; else &apos;,&apos; end || TabelaDestino.column_name  ||&#010;                                      case When  Coalesce(TabelaOrigem.valor_default,&apos;semvalor&apos;) &lt;&gt; &apos;semvalor&apos; Then &apos; = &apos; || TabelaOrigem.valor_default Else &apos; = &apos; || &apos;&apos;&apos;&apos;&apos;&apos; end;   &#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009; End IF;&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;END CASE;&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;      contador := 1;&#010;                      End if; &#010;&#010;                      if TabelaOrigem.tipo &lt;&gt; TabelaDestino.tipo Then &#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;retorno := Retorno  || case When Retorno &lt;&gt; &apos;&apos; Then &apos;;&apos; Else &apos;&apos; end || &apos;alter table &apos; || &#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;pschemadestino || &apos;.&apos; || ptabeladestino || &apos; alter  column &apos; || &#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;Tabelaorigem.column_name || &apos; type &apos; || tabelaorigem.tipo  || &#010;                          &apos; using &apos; || tabelaorigem.column_name || &apos;::&apos; || case TabelaOrigem.tipo when &apos;serial&apos; Then &apos;integer&apos; else tabelaorigem.tipo end;&#010;                      End If;&#010;                      if TabelaOrigem.aceitanulo &lt;&gt; TabelaDestino.aceitanulo Then &#010;                          retorno := Retorno  || case When Retorno &lt;&gt; &apos;&apos; Then &apos;;&apos; Else &apos;&apos; end || &apos;alter table &apos; || pschemadestino || &apos;.&apos; || ptabeladestino || &apos; alter  column &apos; || Tabelaorigem.column_name ||  case when tabelaorigem.aceitanulo Then &apos; drop not null &apos; &#010;                         Else &apos; set not null &apos; End || chr(13) || chr(10); &#010;                      End If;&#010;&#010;                       if  Coalesce(TabelaOrigem.valor_default,&apos;semvalor&apos;) &lt;&gt;  Coalesce(TabelaDestino.valor_default,&apos;semvalor&apos;) Then &#010;                     &#010;                          retorno := Retorno  || case When Retorno &lt;&gt; &apos;&apos; Then &apos;;&apos; Else &apos;&apos; end || &apos;alter table &apos; || pschemadestino || &apos;.&apos; || ptabeladestino || &apos; alter  column &apos; || Tabelaorigem.column_name || &#010;                         case when Coalesce(TabelaOrigem.valor_default,&apos;semvalor&apos;) = &apos;semvalor&apos; Then &apos; drop default &apos; &#010;                         Else &apos; set default  &apos; || tabelaorigem.Valor_default  End ; &#010;                      End If;&#010;&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;End if; &#010;&#009;&#009;&#009; &#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;ELSE&#010;&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;retorno := Retorno  || case When Retorno &lt;&gt; &apos;&apos; Then &apos;;&apos; Else &apos;&apos; end || &apos;alter table &apos; || &#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;pschemadestino || &apos;.&apos; || ptabeladestino || &apos; add  column &apos; || &#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;Tabelaorigem.column_name || &apos; &apos; || tabelaorigem.tipo   ||&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;case when tabelaorigem.aceitanulo Then &apos;&apos; Else &apos;  not null &apos; End  || &#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;case When Coalesce(TabelaOrigem.valor_default,&apos;semvalor&apos;) &lt;&gt; &apos;semvalor&apos; Then &apos; Default  &apos; || TabelaOrigem.valor_default  else &apos; &apos;  End  ; &#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;End If;  &#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;-- RETURN Retorno;&#009;&#010;&#009;&#009;&#009;&#009;&#010;&#009;&#009;&#009;&#009; end loop;&#010;&#010;&#010;&#009;&#009;&#009;&#009;for TabelaOrigem IN&#010;&#009;&#009;&#009;&#009;&#009;&#009; Select&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;nomecoluna column_name&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#010;&#009;&#009;&#009;&#009;&#009;&#009; from&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;pg_class&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009; LEFT JOIN pg_catalog.pg_namespace n&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009; ON n.oid = pg_class.relnamespace&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009; LEFT JOIN atributos_colunas on idobjeto = pg_class.oid      &#010;&#009;&#009;&#009;&#009;&#009;&#009; where &#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009; (lower(nspname),lower(relname))=(lower(pschemadestino),lower(ptabeladestino))&#010;&#009;&#009;&#009;&#009; loop&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009; Select into TabelaDestino &#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009; nomecoluna column_name&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009; from&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;pg_class&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009; LEFT JOIN pg_catalog.pg_namespace n&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009; ON n.oid = pg_class.relnamespace&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009; LEFT JOIN atributos_colunas on idobjeto = pg_class.oid      &#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009; where &#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009; (lower(nspname),lower(relname), nomecoluna)=(lower(pschemaorigem),lower(ptabelaorigem),TabelaOrigem.column_name);&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;-- return  lower(pschemadestino) || lower(ptabeladestino) || TabelaOrigem.column_name;&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009; if not Found THEN&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;retorno := Retorno    || case When Retorno &lt;&gt; &apos;&apos; Then &apos;;&apos; Else &apos;&apos; end || &apos;alter table &apos; || &#010;&#009;&#009;&#009;&#009;&#009;&#009;     &#009;&#009;pschemadestino || &apos;.&apos; || ptabeladestino || &apos; drop  column &apos; || Tabelaorigem.column_name ;&#010;&#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;End If;  &#010;&#009;&#009;&#009;&#009;&#009;&#009;&#009;&#009;-- RETURN Retorno;&#009;&#010;&#009;&#009;&#009;&#009;&#010;&#009;&#009;&#009;&#009; end loop;&#010;&#010;  End If; &#010;  if contador = 1 THEN&#010;     Retorno := &apos;update &apos; || pschemadestino || &apos;.&apos; || ptabeladestino || &apos; &apos; || Retorno2  ||   case When Retorno &lt;&gt; &apos;&apos; Then &apos;;&apos; Else &apos;&apos; end  || retorno;&#010;  End if;&#010;&#010;  RETURN Retorno;&#010;END$function$&#010;"/><ROW RowState="4" tipo="Function" nome="atualizaposicaoestoque(date, integer, character, character, integer, numeric, character)" definicao="CREATE OR REPLACE FUNCTION public.atualizaposicaoestoque(pdata date, pidproduto integer, pidgrade character, ptipoestoque character, pcodigoloja integer, pquantidade numeric, pes character)&#010; RETURNS numeric&#010; LANGUAGE plpgsql&#010;AS $function$&#010;DECLARE&#010;  REC RECORD;&#010;  saldoanterior RECORD; &#010;  entrada double precision;&#010;  saida   double precision;&#010;  saldoa  double precision;&#010;  saldoat numeric;&#010;  contag  double precision;&#010;  iProduto Integer;&#010;  iCodigoLoja Integer;&#010;  cIdentifica_grade char(6);&#010;  &#010; &#010;BEGIN&#010;  iProduto    := pIdProduto; &#010;  iCodigoLoja := pCodigoLoja;&#010;  cIdentifica_grade := pIdGrade; &#010;  &#010;  saldoa   := 0;&#010;  saldoAt  := 0;&#010;  contag   := 0;&#010;  saida    := 0;&#010;  entrada  := 0; &#010;  Case pEs  &#010;     When &apos;E&apos; then -- Se o movimento for entrada. Atribui a quantidade a entrada&#010;&#009;entrada := pquantidade;&#010;     When &apos;S&apos; then -- Se o movimento for saida. Atribui a quantidade a saida&#010;        saida := pquantidade;&#010;        entrada   := 0;&#010;     When  &apos;C&apos; then  -- Se o movimento for contagem de balanco. Atribui a quantidade a contagem&#010;        contag := pquantidade;&#010;        saida := 0;&#010;        entrada := 0;  &#010;     When  &apos;D&apos; then  -- Desfazer balanco&#010;        contag := 0;&#010;        saida := 0;&#010;        entrada := 0;  &#010;  End Case;&#010;  &#010;  --Carrega saldo anterior&#010;  Select Into saldoanterior &#010;      * &#010;  From &#010;      produtoposicaodiaria &#010;  Where  data &lt; pData and &#010;      idproduto = pIdproduto  and &#010;      produtoposicaodiaria.codigoloja = pcodigoloja and &#010;      produtoposicaodiaria.tipoestoque = ptipoestoque  and &#010;      (Coalesce(idgrade,&apos;&apos;) = Coalesce(pidgrade,&apos;&apos;)) &#010;  order by &#010;      data desc limit 1;&#009;&#010;      &#010;  saldoa := Coalesce(saldoanterior.saldo,0);&#010;  --Carrega saldo Atual   &#010;  Select Into REC &#010;     * &#010;  From &#010;      produtoposicaodiaria &#010;  Where &#010;      data = pData and &#010;      idproduto = pIdproduto  and &#010;      produtoposicaodiaria.codigoloja = pcodigoloja  and &#010;      produtoposicaodiaria.tipoestoque = ptipoestoque  and &#010;      (Coalesce(idgrade,&apos;&apos;) = Coalesce(pidgrade,&apos;&apos;)) &#010;  order by &#010;      data desc limit 1;&#010;&#010;  if pes = &apos;C&apos; THEN -- se o movimento for uma contagem, atribui a contagem ao saldo do inicio do dia&#010;     saldoa := contag;&#010;  End If;  &#010;  If rec.data  is  null  then -- testa se ja existe uma posicao de saldo para o dia, se nao existir insere   &#010;        FOR REC IN &#010;            Insert Into produtoposicaodiaria&#010;                   (&#010;                    balanco,&#010;                    contagem, &#010;                    tipoestoque,&#010;                    codigoloja,&#010;                    idproduto,&#010;                    idgrade,&#010;                    data,&#010;                    entradas,&#010;                    saidas,&#010;                    precocompra,&#010;                    precocusto,&#010;                    customedio,&#010;                    saldo,&#010;                    dataoperacao,&#010;                    horaoperacao&#010;                   )&#010;                  Values&#010;                  (&#010;                   pes=&apos;C&apos;,&#010;                   contag,&#010;                   pTipoEstoque,&#010;                   pcodigoloja,&#010;                   pIdproduto,&#010;                   Coalesce(pIdgrade,&apos;&apos;),&#010;                   pData,&#010;                   Coalesce(entrada,0),&#010;                   Coalesce(saida,0),&#010;                   0,&#010;                   0,&#010;                   0,&#010;                   saldoa + Coalesce(entrada,0)-Coalesce(saida,0),&#010;                   current_date,current_time&#010;                   ) &#010;                   Returning *&#010;        loop&#010;        End Loop;&#010;  Else -- se ja existir, atualiza &#010;        FOR REC IN &#010;            Update produtoposicaodiaria&#010;                set&#010;                  (&#010;                   horaoperacao,&#010;                   dataoperacao,&#010;                   balanco, &#010;                   contagem,&#010;                   idproduto,&#010;                   idgrade,&#010;                   data,&#010;                   entradas,&#010;                   saidas,&#010;                   precocompra,&#010;                   precocusto,&#010;                   customedio,&#010;                   saldo&#010;                  ) &#010;                   =&#010;                  (&#010;                   current_time,&#010;                   current_date,&#010;                   case pes When &apos;C&apos; Then  True When &apos;D&apos; Then False Else balanco End,&#010;                   case When contag = 0 Then contagem else contag End,&#010;                   pIdproduto,&#010;                   Coalesce(pIdgrade,&apos;&apos;),&#010;                   pData,&#010;                   Coalesce(entradas,0) + Coalesce(entrada,0),&#010;                   Coalesce(saidas,0) + Coalesce(saida,0),0,0,0,saldoa + Coalesce(entradas,0)-Coalesce(saidas,0)&#010;                  ) &#010;             Where  &#010;                 (DATA,idproduto,tipoestoque,codigoloja) = (pData,pIdproduto,ptipoestoque,pcodigoloja)   and &#010;                 ( Coalesce(idgrade,&apos;&apos;) = Coalesce(pidgrade,&apos;&apos;)) &#010;             Returning *&#010;        loop        &#010;        End Loop; &#010;&#010;   End if;  &#010;   &#010;   -- atribui o saldo dia para recalcular os dias posteriores&#010;   Saldoa := Coalesce(REC.saldo,0);&#010;   Saldoat := Coalesce(REC.saldo,0); &#010;   -- percorre os dias posteriores e recalcula saldo &#010;   For REC in   &#010;       Select  &#010;          * &#010;       From &#010;         produtoposicaodiaria &#010;       Where data &gt; pData  and &#010;         idproduto = pIdproduto  and &#010;         produtoposicaodiaria.codigoloja = pcodigoloja and &#010;         produtoposicaodiaria.tipoestoque = ptipoestoque    and &#010;         (Coalesce(idgrade,&apos;&apos;) = Coalesce(pidgrade,&apos;&apos;)) &#010;       order by data asc&#010;   Loop&#010;       If Coalesce(REC.balanco,false) THEN&#010;          Saldoat :=  Coalesce(REC.contagem,0);&#010;       End If; &#010;       Update produtoposicaodiaria &#010;         set &#010;            dataoperacao = current_date, &#010;            horaoperacao = current_time, &#010;            saldo        = saldoat + Coalesce(Rec.entradas,0) - Coalesce(Rec.saidas,0) Where idprodutoposicaodiaria = Rec.idprodutoposicaodiaria;&#010;&#010;       saldoat = saldoat + Coalesce(Rec.entradas,0) - Coalesce(Rec.saidas,0);&#010;&#010;   End Loop;&#010;&#010;   IF Coalesce(pidgrade,&apos;&apos;)&lt;&gt;&apos;&apos; THEN&#010;      EXECUTE FEstoqueGradeCriaRegistro(pCodigoLoja, pIdProduto, pIdGrade); -- CRIA REGISTRO DE GRADE CASO NAO EXISTA&#010;   END IF;&#010;&#010;   If pEs=&apos;D&apos; or pEs=&apos;C&apos; THEN&#010;      If pTipoestoque=&apos;L&apos; THEN&#010;         IF Coalesce(pidgrade,&apos;&apos;)=&apos;&apos; THEN&#010;&#009;    UPDATE estoqfil set estreal = coalesce( round(saldoat, 3) ,0) WHERE (produto, filial) = (pidproduto, pcodigoloja);&#010;&#009; ELSE&#010; &#009;    UPDATE grade_estoque SET loja = Coalesce(saldoat,0) WHERE (idproduto, idfilial, identifica_grade) = ( pidproduto, pcodigoloja, pidgrade);&#010;            -- atualiza saldo da loja pegando a soma dos saldos dos itens da grade&#010;&#009;    UPDATE &#010;&#009;&#009;estoqfil &#010;&#009;    SET &#010;                estreal  =(select sum(loja)     from grade_estoque where idproduto = pIdProduto And idfilial = pCodigoLoja), &#010;                estfiscal=(select sum(deposito) from grade_estoque where idproduto = pIdProduto and idfilial = pCodigoLoja)&#010;            WHERE &#010;&#009;&#009;produto=pIdProduto AND filial=pCodigoLoja;&#010;         END If;   &#010;      ELSE&#010;         IF Coalesce(pidgrade,&apos;&apos;)=&apos;&apos; THEN&#010;            UPDATE estoqfil set estfiscal = coalesce( round(saldoat, 3) ,0) WHERE (produto, filial) = (pidproduto, pcodigoloja);&#010;&#009; ELSE&#010;&#009;    UPDATE grade_estoque SET deposito = Coalesce(saldoat,0) WHERE (idproduto, idfilial, identifica_grade) = ( pidproduto, pcodigoloja, pidgrade);&#010;            -- atualiza saldo do deposito pegando a soma dos saldos dos itens da grade&#010;&#009;    UPDATE &#010;&#009;&#009;estoqfil &#010;&#009;    SET &#010;                estreal=(select sum(loja) from grade_estoque where idproduto = pIdProduto And idfilial = pCodigoLoja), &#010;                estfiscal=(select sum(deposito) from grade_estoque where idproduto=pIdProduto and idfilial=pCodigoLoja)&#010;            WHERE &#010;&#009;&#009;produto=pIdProduto AND filial=pCodigoLoja;&#010;         End If;   &#010;      END If;&#010;   End IF;&#010;&#010;  --retorna saldo         &#010;   Return Coalesce(saldoat,0);&#010;END;&#010;&#010;$function$&#010;"/><ROW RowState="4" tipo="Type" nome="dblink_pkey_results" definicao="Create type dblink_pkey_results as &#013;&#010;&#009;&#009;(&#013;&#010;&#013;&#010;&#009;&#009;position integer  ,&#013;&#010;&#009;&#009;colname text  &#013;&#010;&#009;&#009;)"/><ROW RowState="4" tipo="Sequence" nome="balancoitens_idbalancoitens_seq" definicao="Create Sequence  balancoitens_idbalancoitens_seq&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1"/><ROW RowState="4" tipo="Function" nome="sem_acento(text)" definicao="CREATE OR REPLACE FUNCTION public.sem_acento(text)&#010; RETURNS text&#010; LANGUAGE sql&#010; IMMUTABLE STRICT&#010;AS $function$ &#010;    SELECT translate(upper($1),&apos;&#225;&#224;&#226;&#227;&#228;&#233;&#232;&#234;&#235;&#237;&#236;&#239;&#243;&#242;&#244;&#245;&#246;&#250;&#249;&#251;&#252;&#193;&#192;&#194;&#195;&#196;&#201;&#200;&#202;&#203;&#205;&#204;&#207;&#211;&#210;&#212;&#213;&#214;&#218;&#217;&#219;&#220;&#231;&#199;&apos;, &#010;                        &apos;aaaaaeeeeiiiooooouuuuAAAAAEEEEIIIOOOOOUUUUcC&apos;);&#010;$function$&#010;"/><ROW RowState="4" tipo="Sequence" nome="a_munici_sq" definicao="Create Sequence  a_munici_sq&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1"/><ROW RowState="4" tipo="Sequence" nome="tef_sequencia" definicao="Create Sequence  tef_sequencia&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 999999999999 START 1"/><ROW RowState="4" tipo="Sequence" nome="balancocontagens_idcontagembalanco_seq" definicao="Create Sequence  balancocontagens_idcontagembalanco_seq&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1"/><ROW RowState="4" tipo="Function" nome="trigger_movimentacaoitens()" definicao="CREATE OR REPLACE FUNCTION public.trigger_movimentacaoitens()&#010; RETURNS trigger&#010; LANGUAGE plpgsql&#010;AS $function$&#010;DECLARE &#010;  REC RECORD; ESTLOTES RECORD; ESTOQUEITEM RECORD; ESTOQUEGRADE RECORD; _fat integer; quant numeric;&#010;  _fator numeric;&#010;BEGIN&#010;   if NEW.mov  = &apos;E&apos; THEN&#010;      _fat := 1;&#010;   ELSE&#010;      _fat := -1;&#010;   End If;&#010;&#010;  &#010;    IF TG_OP = &apos;INSERT&apos;   THEN&#010;       SELECT Into ESTOQUEITEM produto FROM estoqfil WHERE produto = NEW.produto and filial = NEW.filial;&#010;       if ESTOQUEITEM IS NULL THEN&#010;          INSERT INTO ESTOQFIL (PRODUTO, FILIAL, ESTREAL, ESTFISCAL) VALUES (NEW.produto, NEW.FILIAL, 0, 0);&#010;       end if;&#010;&#010;       IF NEW.identifica_grade&lt;&gt;&apos;&apos; Then &#010;          SELECT Into EstoqueGrade idproduto FROM grade_estoque WHERE idproduto=NEW.produto AND idfilial=NEW.filial AND identifica_grade=NEW.identifica_grade;&#010;          If EstoqueGrade Is Null Then&#010;            INSERT INTO grade_estoque (idproduto, idfilial, identifica_grade, Loja, Deposito) values (New.Produto, New.filial, New.identifica_grade, 0, 0);&#010;          End if;&#010;       End if;&#010;    &#010;       If NEW.movimenta_estoque IS NULL THEN -- linhas adicionadas para assegurar kardem em icshs desatualizados ou rotinas onde nao se informa controla_estoque&#010;          SELECT INTO NEW.movimenta_estoque movestoq FROM tipomov WHERE codigo=(Select opcomerc FROM movim1 WHERE movim1.LINK=new.link AND movim1.filial=new.filial);&#010;       END IF;    &#010;     &#010;     if (NEW.movimenta_estoque=&apos;S&apos;)  Then         &#010;            -- insere um novo registro no kardex, referente a entrada ou saida   &#010;            NEW.idkardex :=  nextval(&apos;kardex_idkardex_seq&apos;);&#010;             select into rec * from estoque where codigo = new.produto;&#010;            INSERT INTO&#010;               kardex&#010;                (&#010;                 idgrade,&#010;                 idkardex,&#010;                 idproduto,&#010;                 tipoestoque,&#010;                 codigoloja,&#010;                 data,&#010;                 tipo,&#010;                 es,&#010;                 unidade,&#010;                 fator,&#010;                 quantidade,&#010;                 descricao,&#010;                 codigousuario&#010;                ) &#010;                VALUES&#010;               ( &#010;                 coalesce(new.identifica_grade,&apos;&apos;),&#010;                 NEW.idkardex,&#010;                 new.produto,&#010;                 NEW.tipoestoque,&#010;                 new.filial,&#010;                 NEW.data,&#010;                 &apos;M&apos;,&#010;                 new.mov,&#010;                 case when new.fator = 1 and REC.fracao = &apos;S&apos; then rec.unidfracao else  rec.unidade end,&#010;                 greatest(new.fator,1),&#010;                 new.quantidade,&#010;                 &apos;Referente a  movimentacao via operacao comercial&apos;,&#010;                 0&#010;&#010;                ) ;&#010;         /*If Coalesce(NEW.lote,&apos;&apos;) &lt;&gt; &apos;&apos; THEN&#010;            &#010;            --Testa se ja existe esse lote&#010;            &#010;            Select into ESTLOTES * from estoquelotes where idproduto = NEW.produto and idgrade = NEW.identifica_grade and lote = lote;&#010;            if ESTLOTES IS NULL THEN&#010;               -- insere lote novo &#010;               FOR ESTLOTES IN Insert into estoquelotes (idproduto,idgrade,lote,fabricacao,validade,saldo) values (NEW.produto,NEW.identifica_grade,NEW.lote,NEW.fabricacao,NEW.validade,(NEW.quantidade / NEW.fator) * _fat )  RETURNING idestoquelotes &#010;               loop&#010;                   NEW.idestoquelotes := ESTLOTES.idestoquelotes;&#010;               End Loop;&#010;            ELSE&#010;               -- Soma/Subtrai Estoque do registro novo &#010;               UPDATE estoquelotes Set saldo = saldo +  ( (NEW.quantidade / NEW.fator) * _fat ) where idproduto = NEW.produto and idgrade = NEW.identifica_grade and lote = lote;&#010;            End If;&#010;         End If;*/     &#010;&#009; End if;&#010;&#009;     &#010;         RETURN NEW;&#010;&#009; &#010; ELSEIF TG_OP = &apos;UPDATE&apos;&#009;THEN&#010;       if NEW.movimenta_estoque = &apos;S&apos; then&#010;         select into rec * from estoque where codigo = new.produto;&#010;&#010;         IF NEW.cancelada=&apos;S&apos; THEN&#010;            quant := 0;&#010;         else&#010;           quant := new.quantidade;    &#010;         End If;   &#010;            &#010;            -- altera registro no kardex, referente a entrada ou saida       &#010;            UPDATE &#010;               kardex&#010;                SET&#010;                (&#010;                 idgrade,&#010;                 idkardex,&#010;                 idproduto,&#010;                 tipoestoque,  &#010;                 codigoloja,&#010;                 data,&#010;                 tipo,&#010;                 es,&#010;                 unidade,&#010;                 fator,&#010;                 quantidade,&#010;                 descricao,&#010;                 codigousuario&#010;                ) &#010;                = &#010;               ( &#010;                 coalesce(new.identifica_grade,&apos;&apos;),&#010;                 NEW.idkardex,&#010;                 new.produto,&#010;                 NEW.tipoestoque,&#010;                 NEW.filial,&#010;                 NEW.data,&#010;                 &apos;M&apos;,&#010;                 new.mov,&#010;                 case when new.fator = 1 and REC.fracao=&apos;S&apos; then rec.unidfracao else  rec.unidade end,&#010;                 greatest(new.fator,1),&#010;                 quant,&#010;                 &apos;Referente a  movimentacao via operacao comercial&apos;,&#010;                 0&#010;&#010;&#010;                )   WHERE idkardex = old.idkardex;&#010;&#010;/*&#010;               If Coalesce(OLD.lote,&apos;&apos;) &lt;&gt; &apos;&apos; THEN&#010;                  -- Retira/Repoe Estoque do registro antigo &#010;                  UPDATE estoquelotes Set saldo = saldo +  ( (OLD.quantidade / OLD.fator) * ( _fat * -1 ) ) where idproduto = NEW.produto and idgrade = NEW.identifica_grade and lote = lote;&#010;               End If;     &#010;&#010;               If Coalesce(NEW.lote,&apos;&apos;) &lt;&gt; &apos;&apos; THEN&#010;                  &#010;                  Select into ESTLOTES * from estoquelotes where idproduto = NEW.produto and idgrade = NEW.identifica_grade and lote = lote;&#010;                  if ESTLOTES IS NULL THEN&#010;                     FOR ESTLOTES IN Insert into estoquelotes (idproduto,idgrade,lote, datafabricacao,datavalidade,saldo) values (NEW.produto,NEW.identifica_grade,NEW.lote,NEW.datafabricacao,NEW.datavalidade,(NEW.quantidade / NEW.fator) * _fat )  RETURNING idestoquelotes &#010;                     loop&#010;                       NEW.idestoquelotes := ESTLOTES.idestoquelotes;&#010;                     End Loop;&#010;                  ELSE&#010;                    -- Soma/Subtrai Estoque do registro novo &#010;                    UPDATE estoquelotes Set saldo = saldo +  ( (NEW.quantidade / NEW.fator) * _fat ) where idproduto = NEW.produto and idgrade = NEW.identifica_grade and lote = lote;&#010;                  End If;&#010;               End If;     */&#010;&#010;       End if;&#010;&#009;&#010;&#009; RETURN NEW;&#010;END IF;&#010;IF TG_OP = &apos;DELETE&apos; and old.movimenta_estoque = &apos;S&apos; THEN&#010;    -- Retira/Repoe Estoque do registtro deletado &#010;    /*If Coalesce(OLD.lote,&apos;&apos;) &lt;&gt; &apos;&apos; THEN&#010;       UPDATE estoquelotes Set saldo = saldo +  ( (OLD.quantidade / OLD.fator) * ( _fat * -1 ) ) where idproduto = NEW.produto and idgrade = NEW.identifica_grade and lote = lote;&#010;    End If;     */&#010;&#010;&#009;&#010;    -- apaga registro do kardex&#010;    Delete from kardex  where idkardex = old.idkardex; &#010;&#010;&#009;&#009;RETURN OLD;&#010;END IF;&#010;&#009;&#010;END;&#010;$function$&#010;"/><ROW RowState="4" tipo="View" nome="vs_colaboradores" definicao="Create View vs_colaboradores&#013;&#010;&#009;&#009; as &#013;&#010; SELECT colaboradores.codigo,&#010;    colaboradores.datacad,&#010;    colaboradores.nome,&#010;    colaboradores.apelido,&#010;    colaboradores.endereco,&#010;    colaboradores.bairro,&#010;    colaboradores.cidade,&#010;    colaboradores.uf,&#010;    colaboradores.cep,&#010;    colaboradores.fone,&#010;    colaboradores.di,&#010;    colaboradores.cpf,&#010;    colaboradores.comis,&#010;    colaboradores.comis2,&#010;    colaboradores.mov,&#010;    colaboradores.fone2,&#010;    colaboradores.inativo,&#010;    colaboradores.idcargofunc,&#010;    colaboradores.filial,&#010;    funcoes.cargo_descricao AS descricao_funcao,&#010;    funcoes.isvendedor,&#010;    funcoes.isprodutivo,&#010;    funcoes.iscolaborador AS isindicador,&#010;    funcoes.supervisor,&#010;    funcoes.perc_repasse_indicacao&#010;   FROM (vendedor colaboradores&#010;   LEFT JOIN cargos_funcoes funcoes ON ((funcoes.idcargofunc = colaboradores.idcargofunc)));&#013;&#010;"/><ROW RowState="4" tipo="Function" nome="fconsultacliente(integer)" definicao="CREATE OR REPLACE FUNCTION public.fconsultacliente(pcodigocliente integer)&#010; RETURNS character&#010; LANGUAGE plpgsql&#010;AS $function$&#010; DECLARE &#010;   REC RECORD;&#010;BEGIN&#010;   SELECT INTO REC &#010;      * &#010;   FROM&#010;&#009;clientes&#010;   WHERE&#010;&#009;codigo=pcodigocliente;&#010;   RETURN REC.nome;&#010;END;&#010;&#010;$function$&#010;"/><ROW RowState="4" tipo="Sequence" nome="movim2_controle_seq" definicao="Create Sequence  movim2_controle_seq&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1"/><ROW RowState="4" tipo="Sequence" nome="pedido2_chave_seq" definicao="Create Sequence  pedido2_chave_seq&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1"/><ROW RowState="4" tipo="Sequence" nome="tab_boleto_layouts_instrucoesremessa_tipoinstrucaoremessa_seq" definicao="Create Sequence  tab_boleto_layouts_instrucoesremessa_tipoinstrucaoremessa_seq&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1"/><ROW RowState="4" tipo="View" nome="vs_triggers" definicao="Create View vs_triggers&#013;&#010;&#009;&#009; as &#013;&#010; SELECT triggers.trigger_catalog,&#010;    triggers.trigger_schema,&#010;    triggers.trigger_name,&#010;    triggers.event_manipulation,&#010;    triggers.event_object_catalog,&#010;    triggers.event_object_schema,&#010;    triggers.event_object_table,&#010;    triggers.action_order,&#010;    triggers.action_condition,&#010;    triggers.action_statement,&#010;    triggers.action_orientation,&#010;    triggers.action_timing,&#010;    triggers.action_reference_old_table,&#010;    triggers.action_reference_new_table,&#010;    triggers.action_reference_old_row,&#010;    triggers.action_reference_new_row,&#010;    triggers.created&#010;   FROM information_schema.triggers;&#013;&#010;"/><ROW RowState="4" tipo="View" nome="vs_loja" definicao="Create View vs_loja&#013;&#010;&#009;&#009; as &#013;&#010; SELECT lojas.codigo,&#010;    lojas.filial,&#010;    lojas.endereco,&#010;    lojas.bairro,&#010;    lojas.cidade,&#010;    lojas.uf,&#010;    lojas.cep,&#010;    lojas.fone,&#010;    lojas.fax,&#010;    lojas.cnpj,&#010;    lojas.insc,&#010;    lojas.icms,&#010;    lojas.ultrec,&#010;    lojas.ultcontrato,&#010;    lojas.arqcarne,&#010;    lojas.idmunicipio,&#010;    lojas.cnae,&#010;    lojas.nfe_chave,&#010;    lojas.nfe_lote,&#010;    lojas.insc_municipal,&#010;    lojas.email,&#010;    lojas.nfe_scan_serie,&#010;    lojas.nfe_scan_numero,&#010;    lojas.endereco_complemento,&#010;    lojas.nfe_chave_teste,&#010;    lojas.nfe_lote_teste,&#010;    lojas.endereco_numero,&#010;    lojas.crt,&#010;    lojas.email_smtp,&#010;    lojas.email_smtp_porta,&#010;    lojas.email_usuario,&#010;    lojas.email_senha,&#010;    lojas.email_conexaosegura,&#010;    lojas.email_nfe_mensagem,&#010;    lojas.nfe_scan_numero_teste,&#010;    lojas.x9,&#010;    lojas.razaosocial,&#010;    lojas.regime_piscofins,&#010;    lojas.aliquota_iss,&#010;    lojas.aliquota_ir,&#010;    lojas.aliquota_csll,&#010;    lojas.aliquota_pis_saida,&#010;    lojas.aliquota_cofins_saida,&#010;    lojas.nfse_ultimo_lote,&#010;    lojas.nfse_ultima_nota,&#010;    lojas.nfse_ultimo_rps,&#010;    lojas.nfse_validade_rps,&#010;    lojas.cpf_contabilista,&#010;    lojas.site,&#010;    lojas.aliquota_simplesnacional,&#010;    lojas.aliquota_inss&#010;   FROM lojas;&#013;&#010;"/><ROW RowState="4" tipo="Sequence" nome="ajusteestoque_codigo_key" definicao="Create Sequence  ajusteestoque_codigo_key&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1"/><ROW RowState="4" tipo="View" nome="vs_operacaocomercial" definicao="Create View vs_operacaocomercial&#013;&#010;&#009;&#009; as &#013;&#010; SELECT opcomerc.codigo AS codigooperacaocomercial,&#010;    opcomerc.descricao AS descricaooperacaocomercial,&#010;    opcomerc.reduzido AS siglaoperacaocomercial,&#010;    opcomerc.movcomerc AS tipomovimento,&#010;    opcomerc.cfop_padrao AS cfop_dentro,&#010;    opcomerc.cfop_padrao_fora AS cfop_fora,&#010;    opcomerc.idtabela AS codigotabpreco_ncontribuinte,&#010;    opcomerc.idtabela_pj AS codigotabpreco_contribuinte,&#010;    opcomerc.desconto AS descontomaximonota,&#010;    opcomerc.negativo AS estoquenegativo,&#010;    opcomerc.travarpreco,&#010;    opcomerc.soestfiscal AS controlaestoquedeposito,&#010;    opcomerc.calcula_impostos,&#010;    opcomerc.contabil AS documentofiscal,&#010;    opcomerc.preco AS precoutilizado,&#010;    opcomerc.calculacustomedioitens,&#010;    opcomerc.quantidademaximaservicos,&#010;    opcomerc.maxprod AS quantidademaximaprodutos,&#010;    opcomerc.movestoq AS controlaestoque,&#010;    opcomerc.serie_nf,&#010;    opcomerc.descontomaximoitem,&#010;    opcomerc.inativo,&#010;    ct_custos.codigo AS idcentrodecusto,&#010;    ct_custos.descricao AS descricaoctcusto&#010;   FROM (tipomov opcomerc&#010;   LEFT JOIN ct_custos ON ((ct_custos.codigo = opcomerc.idctcusto)));&#013;&#010;"/><ROW RowState="4" tipo="Type" nome="tkardex" definicao="Create type tkardex as &#013;&#010;&#009;&#009;(&#013;&#010;&#013;&#010;&#009;&#009;codigo integer  ,&#013;&#010;&#009;&#009;grade character(6)  ,&#013;&#010;&#009;&#009;descricao character(50)  ,&#013;&#010;&#009;&#009;descricaograde character(50)  ,&#013;&#010;&#009;&#009;unidadepadrao character(3)  ,&#013;&#010;&#009;&#009;unidademovimentada character(3)  ,&#013;&#010;&#009;&#009;data date  ,&#013;&#010;&#009;&#009;tipomovimentacao character(1)  ,&#013;&#010;&#009;&#009;operacaocomercial integer  ,&#013;&#010;&#009;&#009;nota integer  ,&#013;&#010;&#009;&#009;descricaomovimentacao character(50)  ,&#013;&#010;&#009;&#009;saldoanterior double precision  ,&#013;&#010;&#009;&#009;quantidade double precision  ,&#013;&#010;&#009;&#009;balanco boolean  ,&#013;&#010;&#009;&#009;fator numeric(20,6)  ,&#013;&#010;&#009;&#009;saldoatual double precision  ,&#013;&#010;&#009;&#009;fracionado boolean  &#013;&#010;&#009;&#009;)"/><ROW RowState="4" tipo="View" nome="vs_fotoconsultaenvelope" definicao="Create View vs_fotoconsultaenvelope&#013;&#010;&#009;&#009; as &#013;&#010; SELECT foto_mov1.idenvelope,&#010;    foto_mov1.idcliente,&#010;    cli.nome AS nomecliente,&#010;    cli.apelido AS apelidocliente,&#010;    cli.fone AS fonecliente,&#010;        CASE&#010;            WHEN ((cli.tipo)::text = &apos;F&apos;::text) THEN cli.cpf&#010;            ELSE cli.cnpj&#010;        END AS cpf_cnpj,&#010;    foto_mov1.dtentrada,&#010;    foto_mov1.previsaoentrega,&#010;    foto_mov1.dataentrega,&#010;    foto_mov1.valor_servicos,&#010;    foto_mov1.descontos,&#010;    foto_mov1.sinal,&#010;    foto_mov1.total,&#010;    foto_mov1.fechado,&#010;    foto_mov1.pagto,&#010;    foto_mov1.idlaboratorista&#010;   FROM (foto_mov1&#010;   JOIN clientes cli ON ((cli.codigo = foto_mov1.idcliente)));&#013;&#010;"/><ROW RowState="4" tipo="View" nome="vs_catalogo" definicao="Create View vs_catalogo&#013;&#010;&#009;&#009; as &#013;&#010;         SELECT c.oid AS id,&#010;            n.nspname AS schema,&#010;            (c.relname)::text AS nome,&#010;                CASE c.relkind&#010;                    WHEN &apos;r&apos;::&quot;char&quot; THEN &apos;Table&apos;::text&#010;                    WHEN &apos;v&apos;::&quot;char&quot; THEN &apos;View&apos;::text&#010;                    WHEN &apos;i&apos;::&quot;char&quot; THEN &apos;index&apos;::text&#010;                    WHEN &apos;S&apos;::&quot;char&quot; THEN &apos;Sequence&apos;::text&#010;                    WHEN &apos;c&apos;::&quot;char&quot; THEN &apos;Type&apos;::text&#010;                    WHEN &apos;s&apos;::&quot;char&quot; THEN &apos;special&apos;::text&#010;                    ELSE (c.relkind)::text&#010;                END AS tipo,&#010;                CASE&#010;                    WHEN (c.relname = ANY (ARRAY[&apos;cep_bairros&apos;::name, &apos;cep_cidades&apos;::name, &apos;cep_enderecos&apos;::name])) THEN 1&#010;                    WHEN (c.relname = ANY (ARRAY[&apos;bancos_padrao&apos;::name, &apos;ceps&apos;::name, &apos;document&apos;::name, &apos;dre_contas&apos;::name, &apos;dre_grupos&apos;::name, &apos;dre_modelos&apos;::name, &apos;natoperac&apos;::name, &apos;paf_softhouse&apos;::name, &apos;tab_uf&apos;::name, &apos;tab_municipios&apos;::name, &apos;tab_ncm&apos;::name])) THEN 2&#010;                    ELSE 3&#010;                END AS tipodesincronismodedados,&#010;            (pg_size_pretty(pg_total_relation_size((c.oid)::regclass)))::character varying(15) AS tamanho,&#010;            &apos;&apos;::text AS scopo&#010;           FROM (pg_class c&#010;      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))&#010;     WHERE ((c.relkind = ANY (ARRAY[&apos;r&apos;::&quot;char&quot;, &apos;v&apos;::&quot;char&quot;, &apos;S&apos;::&quot;char&quot;, &apos;c&apos;::&quot;char&quot;])) AND (n.nspname = &quot;current_schema&quot;()))&#010;UNION&#010;         SELECT p.oid AS id,&#010;            n.nspname AS schema,&#010;            (((quote_ident((p.proname)::text) || &apos;(&apos;::text) || oidvectortypes(p.proargtypes)) || &apos;)&apos;::text) AS nome,&#010;            &apos;Function&apos;::text AS tipo,&#010;            1 AS tipodesincronismodedados,&#010;            &apos;&apos;::character varying(15) AS tamanho,&#010;            (p.proargnames)::text AS scopo&#010;           FROM (pg_proc p&#010;      LEFT JOIN pg_namespace n ON ((n.oid = p.pronamespace)))&#010;     WHERE (n.nspname = &quot;current_schema&quot;());&#013;&#010;"/><ROW RowState="4" tipo="View" nome="vercontas2" definicao="Create View vercontas2&#013;&#010;&#009;&#009; as &#013;&#010; SELECT contas.chave,&#010;    contas.filial,&#010;    contas.tipo,&#010;    contas.clifor,&#010;    contas.portador,&#010;    contas.vendedor,&#010;    contas.tipodoc,&#010;    contas.ctcusto,&#010;    contas.documento,&#010;    contas.prestacao,&#010;    contas.historico,&#010;    contas.dtlanc,&#010;    contas.vencimento,&#010;    contas.valordoc,&#010;    contas.pagamento,&#010;    contas.valorpago,&#010;    contas.valorsaldo,&#010;    contas.jurosnpg,&#010;    contas.baixa,&#010;    contas.chavestoq,&#010;    contas.contabil,&#010;    contas.idmovim1,&#010;    to_number(((((&apos;now&apos;::text)::date)::timestamp without time zone - (contas.vencimento)::timestamp without time zone))::text, &apos;99999&apos;::text) AS da,&#010;    contas.status,&#010;    contas.contrato&#010;   FROM contas;&#013;&#010;"/><ROW RowState="4" tipo="View" nome="vs_municipios" definicao="Create View vs_municipios&#013;&#010;&#009;&#009; as &#013;&#010; SELECT municipio.id,&#010;    municipio.nome,&#010;    uf.nome AS uf,&#010;    uf.sigla AS siglauf,&#010;    municipio.iduf&#010;   FROM (tab_municipios municipio&#010;   LEFT JOIN tab_uf uf ON ((uf.iduf = municipio.iduf)));&#013;&#010;"/><ROW RowState="4" tipo="Sequence" nome="produto_fracionamentocompra_codigoprodutofracioncompra_seq" definicao="Create Sequence  produto_fracionamentocompra_codigoprodutofracioncompra_seq&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1"/><ROW RowState="4" tipo="Sequence" nome="ajusteestoque_codigo_seq" definicao="Create Sequence  ajusteestoque_codigo_seq&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1"/><ROW RowState="4" tipo="Function" nome="script_drop(character, character, character, character, boolean)" definicao="CREATE OR REPLACE FUNCTION public.script_drop(pobjeto character, ptipo character, pschema character, pscopo character, pexecutar boolean)&#010; RETURNS text&#010; LANGUAGE plpgsql&#010;AS $function$ DECLARE &#010;      REC RECORD;&#010;      DESCRICAO Text;&#010;      Contador integer;&#010;      linguagem Text;&#010;&#010;BEGIN&#010;contador := 0;&#010;if ptipo = &apos;Table&apos; THEN&#010;    Descricao := &apos;DROP  Table &apos; ||  pschema || &apos;.&apos; || pobjeto || &apos; &#009;CASCADE &apos;  ||chr(13) || chr(10);&#010; &#009;&#009;&#009;&#009;&#010;&#010;elseif pTipo =&apos;View&apos; Then&#010;     Descricao := &apos;DROP  View &apos; ||  pschema || &apos;.&apos; || pobjeto || &apos; &#009;CASCADE &apos;  ||chr(13) || chr(10);&#010; &#010;elseif pTipo =&apos;Sequence&apos; Then&#010;&#010;     Descricao := &apos;DROP  Sequence &apos; ||  pschema || &apos;.&apos; || pobjeto || &apos; &#009;CASCADE &apos;  ||chr(13) || chr(10);&#010; &#010;elseif pTipo like  &apos;%Function%&apos; Then&#010;&#010;select into REC &#010;            &apos;DROP FUNCTION &apos; || quote_ident(ns.nspname) || &apos;.&apos;&#010;                || quote_ident(proname) || &apos;(&apos; || oidvectortypes(proargtypes)&#010;                || &apos;);&apos; AS definicao&#010;            FROM&#010;               pg_proc&#010;            INNER JOIN&#010;               pg_namespace ns&#010;           ON&#010;               (pg_proc.pronamespace = ns.oid)&#010;        WHERE&#010;            ns.nspname = pschema&#010;&#010;        AND   proname = pObjeto;&#010;&#010;&#010; &#010;   if found Then&#010;       Descricao  :=  REC.definicao;&#010;    End If;&#010;  &#010;&#010;    &#010;   &#010;&#010;Elseif ptipo = &apos;Type&apos; THEN&#010;   Descricao := &apos;DROP  TYPE &apos; ||  pschema || &apos;.&apos; || pobjeto || &apos; &#009;CASCADE &apos;  ||chr(13) || chr(10);&#010; &#010;End If;&#010;  if pExecutar THEN&#010;&#010;     execute Descricao;&#010;  End If;&#010;  Return Descricao;&#010;END&#010;$function$&#010;"/><ROW RowState="4" tipo="Sequence" nome="cliente_pagparcial_mov_id_pagparcial_liberacao_seq" definicao="Create Sequence  cliente_pagparcial_mov_id_pagparcial_liberacao_seq&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1"/><ROW RowState="4" tipo="Function" nome="script_drop(character, character, character, boolean)" definicao="CREATE OR REPLACE FUNCTION public.script_drop(pobjeto character, ptipo character, pschema character, pexecutar boolean)&#010; RETURNS text&#010; LANGUAGE plpgsql&#010;AS $function$ DECLARE &#010;      REC RECORD;&#010;      DESCRICAO Text;&#010;      Contador integer;&#010;      linguagem Text;&#010;&#010;BEGIN&#010;contador := 0;&#010;if ptipo = &apos;Table&apos; THEN&#010;    Descricao := &apos;DROP  Table &apos; ||  pschema || &apos;.&apos; || pobjeto || &apos; &#009;CASCADE &apos;  ||chr(13) || chr(10);&#010; &#009;&#009;&#009;&#009;&#010;&#010;elseif pTipo =&apos;View&apos; Then&#010;     Descricao := &apos;DROP  View &apos; ||  pschema || &apos;.&apos; || pobjeto || &apos; &#009;CASCADE &apos;  ||chr(13) || chr(10);&#010; &#010;elseif pTipo =&apos;Sequence&apos; Then&#010;&#010;     Descricao := &apos;DROP  Sequence &apos; ||  pschema || &apos;.&apos; || pobjeto || &apos; &#009;CASCADE &apos;  ||chr(13) || chr(10);&#010; &#010;elseif pTipo like  &apos;%Function%&apos; Then&#010;    Descricao := &apos;DROP  Function &apos; ||  pschema || &apos;.&apos; || pobjeto   ||chr(13) || chr(10);&#010;    &#010;   &#010;&#010;Elseif ptipo = &apos;Type&apos; THEN&#010;   Descricao := &apos;DROP  TYPE &apos; ||  pschema || &apos;.&apos; || pobjeto || &apos; &#009;CASCADE &apos;  ||chr(13) || chr(10);&#010; &#010;End If;&#010;  Return Descricao;&#010;END&#010;$function$&#010;"/><ROW RowState="4" tipo="Type" nome="targetinfo" definicao="Create type targetinfo as &#013;&#010;&#009;&#009;(&#013;&#010;&#013;&#010;&#009;&#009;target oid  ,&#013;&#010;&#009;&#009;schema oid  ,&#013;&#010;&#009;&#009;nargs integer  ,&#013;&#010;&#009;&#009;argtypes oidvector  ,&#013;&#010;&#009;&#009;targetname name  ,&#013;&#010;&#009;&#009;argmodes &quot;char&quot;[]  ,&#013;&#010;&#009;&#009;argnames text[]  ,&#013;&#010;&#009;&#009;targetlang oid  ,&#013;&#010;&#009;&#009;fqname text  ,&#013;&#010;&#009;&#009;returnsset boolean  ,&#013;&#010;&#009;&#009;returntype oid  &#013;&#010;&#009;&#009;)"/><ROW RowState="4" tipo="Type" nome="proxyinfo" definicao="Create type proxyinfo as &#013;&#010;&#009;&#009;(&#013;&#010;&#013;&#010;&#009;&#009;serverversionstr text  ,&#013;&#010;&#009;&#009;serverversionnum integer  ,&#013;&#010;&#009;&#009;proxyapiver integer  ,&#013;&#010;&#009;&#009;serverprocessid integer  &#013;&#010;&#009;&#009;)"/><ROW RowState="4" tipo="Sequence" nome="estoquelotes_idestoquelotes_seq" definicao="Create Sequence  estoquelotes_idestoquelotes_seq&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1"/><ROW RowState="4" tipo="View" nome="vs_planopagtotabprecos" definicao="Create View vs_planopagtotabprecos&#013;&#010;&#009;&#009; as &#013;&#010; SELECT planopagamentotabelapreco.codigotabelapreco,&#010;    planopagamentotabelapreco.codigoplanopagamento,&#010;    tabeladeprecos.descricao_tabela&#010;   FROM (planopagamentotabelapreco&#010;   JOIN tabeladeprecos ON ((tabeladeprecos.idtabela = planopagamentotabelapreco.codigotabelapreco)));&#013;&#010;"/><ROW RowState="4" tipo="Sequence" nome="bxa_contas_lanc_key" definicao="Create Sequence  bxa_contas_lanc_key&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1"/><ROW RowState="4" tipo="Sequence" nome="balanco_idbalanco_seq" definicao="Create Sequence  balanco_idbalanco_seq&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1"/><ROW RowState="4" tipo="Sequence" nome="orcamentobalcao2_controle_key" definicao="Create Sequence  orcamentobalcao2_controle_key&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1"/><ROW RowState="4" tipo="View" nome="ver_movcaixa" definicao="Create View ver_movcaixa&#013;&#010;&#009;&#009; as &#013;&#010; SELECT mov.idmovcaixa,&#010;    mov.idfilial,&#010;    mov.idcaixa,&#010;    mov.historico,&#010;    mov.idctcusto,&#010;    mov.planocta_id,&#010;    pc.codigo_conta,&#010;    pc.nomeconta,&#010;    pc.dc,&#010;    pai.contapai,&#010;    pc.nivelconta,&#010;    mov.valordoc,&#010;    mov.documento,&#010;    mov.dt_abertura,&#010;    pc.analitica,&#010;    pc.tipo_custo,&#010;    mov.usuario&#010;   FROM ((movcaixa mov&#010;   JOIN planodecontas pc ON ((pc.planocta_id = mov.planocta_id)))&#010;   LEFT JOIN ver_planocta_pai pai ON (((pai.codigo_conta)::text = (pc.codigo_conta)::text)));&#013;&#010;"/><ROW RowState="4" tipo="View" nome="vs_gradeposicoes" definicao="Create View vs_gradeposicoes&#013;&#010;&#009;&#009; as &#013;&#010; SELECT grade.nomelinha,&#010;    grade.nomecoluna,&#010;    colunas.identifica_grade,&#010;    grade.idgrade,&#010;    grade.descricao_grade,&#010;    linhas.grade_linha,&#010;        CASE&#010;            WHEN (colunas.idcoluna_linha = ( SELECT min(grade_colunas.idcoluna_linha) AS min&#010;               FROM grade_colunas&#010;              WHERE ((grade_colunas.idgrade_linha = linhas.idgrade_linha) AND (grade_colunas.idgrade = linhas.idgrade)))) THEN linhas.grade_linha&#010;            ELSE &apos; &apos;::bpchar&#010;        END AS linha,&#010;    colunas.nomecoluna_linha&#010;   FROM ((grade_cadastro grade&#010;   JOIN grade_linhas linhas ON ((linhas.idgrade = grade.idgrade)))&#010;   LEFT JOIN grade_colunas colunas ON (((colunas.idgrade = linhas.idgrade) AND (colunas.idgrade_linha = linhas.idgrade_linha))));&#013;&#010;"/><ROW RowState="4" tipo="View" nome="vs_tabelaprecos" definicao="Create View vs_tabelaprecos&#013;&#010;&#009;&#009; as &#013;&#010; SELECT tabeladeprecos.idtabela AS codigotabelapreco,&#010;    tabeladeprecos.descricao_tabela,&#010;    tabeladeprecos.percentual,&#010;    tabeladeprecos.sigla,&#010;    tabeladeprecos.idtaborigem AS codigotabelaorigem&#010;   FROM tabeladeprecos;&#013;&#010;"/><ROW RowState="4" tipo="Sequence" nome="kardex_idkardex_seq" definicao="Create Sequence  kardex_idkardex_seq&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1"/><ROW RowState="4" tipo="View" nome="vs_caixausuarios" definicao="Create View vs_caixausuarios&#013;&#010;&#009;&#009; as &#013;&#010; SELECT caixa_usuarios.codigocaixa,&#010;    caixa_usuarios.codigousuario,&#010;    usuarios.nome&#010;   FROM (caixa_usuarios&#010;   LEFT JOIN usuarios ON ((usuarios.usuario = caixa_usuarios.codigousuario)));&#013;&#010;"/><ROW RowState="4" tipo="Type" nome="var" definicao="Create type var as &#013;&#010;&#009;&#009;(&#013;&#010;&#013;&#010;&#009;&#009;name text  ,&#013;&#010;&#009;&#009;varclass character(1)  ,&#013;&#010;&#009;&#009;linenumber integer  ,&#013;&#010;&#009;&#009;isunique boolean  ,&#013;&#010;&#009;&#009;isconst boolean  ,&#013;&#010;&#009;&#009;isnotnull boolean  ,&#013;&#010;&#009;&#009;dtype oid  ,&#013;&#010;&#009;&#009;value text  &#013;&#010;&#009;&#009;)"/><ROW RowState="4" tipo="Function" nome="trigger_before_kardex()" definicao="CREATE OR REPLACE FUNCTION public.trigger_before_kardex()&#010; RETURNS trigger&#010; LANGUAGE plpgsql&#010;AS $function$&#010;   DECLARE &#010;      Base  Integer;&#010;      Rec   Record;&#010;&#010;&#010;   BEGIN&#010;      IF TG_OP = &apos;INSERT&apos; or TG_OP = &apos;UPDATE&apos; THEN&#010;&#009; If TG_OP = &apos;INSERT&apos;&#009;THEN&#010;                -- Movimenta posicao diaria de estoqueloja&#010;                IF NEW.es&lt;&gt;&apos;C&apos; THEN&#010;                   SELECT into Rec  atualizaposicaoestoque(NEW.data,  NEW.idproduto, NEW.idgrade,new.tipoestoque, NEW.codigoloja,  new.quantidade * new.fator ,  NEW.es);&#010;                END IF;   &#010;&#009; ELSEIF TG_OP = &apos;UPDATE&apos;&#009;THEN&#010;                    &#010;                -- movimenta posicao diaria de estoque fazendo a inversao do registro antigo&#010;                select  into Rec   atualizaposicaoestoque(OLD.data, OLD.idproduto,OLD.idgrade,old.tipoestoque, OLD.codigoloja, ( OLD.quantidade * OLD.fator )* -1,  OLD.ES );&#010;                -- movimenta posicao diaria de estoque fazendo a movimentacao do registro novo&#010;                select  into Rec atualizaposicaoestoque(NEW.data, NEW.idproduto,NEW.idgrade,new.tipoestoque, NEW.codigoloja, ( new.quantidade * new.fator ), NEW.es);&#010;            End If; &#010;              RETURN NEW; &#010;      END IF;&#010;      IF TG_OP = &apos;DELETE&apos; THEN&#010;        --raise exception &apos;excluindo&apos;;&#010;          -- movimenta posicao diaria de estoque fazendo a inversao do registro deletado&#010;          IF OLD.quantidade&lt;&gt;0 THEN&#010;             SELECT Into Rec atualizaposicaoestoque(OLD.data, OLD.idproduto,OLD.idgrade, old.tipoestoque, old.codigoloja, ( OLD.quantidade * OLD.fator ) * -1,  OLD.ES );&#010;          END IF;&#010;          RETURN OLD;&#010;      END IF;&#010;      &#010;   END;&#010;$function$&#010;"/><ROW RowState="4" tipo="Function" nome="drop_all_triggers()" definicao="CREATE OR REPLACE FUNCTION public.drop_all_triggers()&#010; RETURNS text&#010; LANGUAGE plpgsql&#010; SECURITY DEFINER&#010;AS $function$ DECLARE&#010;    triggNameRecord RECORD;&#010;    triggTableRecord RECORD;&#010;BEGIN&#010;    FOR triggNameRecord IN select distinct(trigger_name) from information_schema.triggers where trigger_schema = &apos;public&apos; LOOP&#010;        FOR triggTableRecord IN SELECT distinct(event_object_table) from information_schema.triggers where trigger_name = triggNameRecord.trigger_name LOOP&#010;            RAISE NOTICE &apos;Dropping trigger: % on table: %&apos;, triggNameRecord.trigger_name, triggTableRecord.event_object_table;&#010;            EXECUTE &apos;DROP TRIGGER &apos; || triggNameRecord.trigger_name || &apos; ON &apos; || triggTableRecord.event_object_table || &apos;;&apos;;&#010;        END LOOP;&#010;    END LOOP;&#010;&#010;    RETURN &apos;done&apos;;&#010;END;&#010;$function$&#010;"/><ROW RowState="4" tipo="Sequence" nome="tab_infotef_idinfo_tef_seq" definicao="Create Sequence  tab_infotef_idinfo_tef_seq&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1"/><ROW RowState="4" tipo="View" nome="ver_caixames" definicao="Create View ver_caixames&#013;&#010;&#009;&#009; as &#013;&#010; SELECT ver_movcaixa.nomeconta,&#010;    (((date_part(&apos;month&apos;::text, ver_movcaixa.dt_abertura))::text || &apos;/&apos;::text) || (date_part(&apos;year&apos;::text, ver_movcaixa.dt_abertura))::text) AS mes,&#010;    sum(ver_movcaixa.valordoc) AS total,&#010;    date_part(&apos;year&apos;::text, ver_movcaixa.dt_abertura) AS ano,&#010;    ver_movcaixa.planocta_id,&#010;        CASE&#010;            WHEN (NOT ((ver_movcaixa.dc)::bpchar = ANY (ARRAY[&apos;D&apos;::bpchar, &apos;7&apos;::bpchar, &apos;I&apos;::bpchar]))) THEN &apos;Entradas&apos;::text&#010;            ELSE &apos;Saidas&apos;::text&#010;        END AS tipo&#010;   FROM ver_movcaixa&#010;  GROUP BY date_part(&apos;year&apos;::text, ver_movcaixa.dt_abertura), date_part(&apos;month&apos;::text, ver_movcaixa.dt_abertura), ver_movcaixa.planocta_id, ver_movcaixa.nomeconta, ver_movcaixa.dc&#010;  ORDER BY date_part(&apos;year&apos;::text, ver_movcaixa.dt_abertura), date_part(&apos;month&apos;::text, ver_movcaixa.dt_abertura);&#013;&#010;"/><ROW RowState="4" tipo="Sequence" nome="logusuario_lanc_seq" definicao="Create Sequence  logusuario_lanc_seq&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1"/><ROW RowState="4" tipo="Function" nome="trigger_before_contagensitens()" definicao="CREATE OR REPLACE FUNCTION public.trigger_before_contagensitens()&#010; RETURNS trigger&#010; LANGUAGE plpgsql&#010;AS $function$&#010;   DECLARE &#010;      Rec   Record;&#010;      balanco record;&#010;      retorno balancocontagemitens%rowtype;&#010;      &#010;   BEGIN&#010;&#010;      IF TG_OP = &apos;DELETE&apos; or TG_OP = &apos;UPDATE&apos; THEN  &#010;         -- exclui a quandidade do registro antigo&#010;         update balancoitens set quantidade = quantidade - old.quantidade where local_estoque = old.local_estoque and   idbalanco = old.idbalanco and codigoproduto=old.codigoproduto  and unidade = old.unidade and Coalesce(identifica_grade,&apos;&apos;)=Coalesce(old.identifica_grade,&apos;&apos;);&#010;      End If;&#010;      IF TG_OP = &apos;INSERT&apos; or TG_OP = &apos;UPDATE&apos; THEN&#010;         -- Teste se o produto ja consta em balanco&#010;         &#010;         if TG_OP = &apos;INSERT&apos; Then&#010;            select into balanco * from balancos where idbalanco = new.idbalanco;  &#010;            select into Rec * from balancoitens  left join balancos on balancos.idbalanco = balancoitens.idbalanco  &#010;            where balancos.codigoloja = balanco.codigoloja and   balancoitens.idbalanco &lt;&gt; new.idbalanco and&#010;            ( Coalesce(balancos.situacao,&apos;A&apos;) = &apos;A&apos;  or Coalesce(balancoitens.situacao,&apos;A&apos;) = &apos;A&apos;) and&#010;            balancos.local_estoque = new.local_estoque and codigoproduto = new.codigoproduto and Coalesce(identifica_grade,&apos;&apos;)=Coalesce(new.identifica_grade,&apos;&apos;);&#010;            &#010;            If rec.codigoproduto = new.codigoproduto Then&#010;               Raise Exception &apos;Produto presente no balan&#231;o [%].&apos;,rec.codigobalanco;&#010;               Return  retorno;&#010;            End If;   &#010;         End If;&#010;&#009; &#010;                         &#010;         select into Rec  * from  balancoitens  where local_estoque = new.local_estoque and idbalanco = new.idbalanco  and codigoproduto = new.codigoproduto and unidade = new.unidade  and Coalesce(identifica_grade,&apos;&apos;)=Coalesce(NEW.identifica_grade,&apos;&apos;);&#010;         if rec is null Then&#010;            insert into  balancoitens (idbalanco,local_estoque,  codigoproduto, unidade,  fator, quantidade,  identifica_grade, situacao) &#010;                   values&#010;                         (new.idbalanco,new.local_estoque,  new.codigoproduto, new.unidade,  new.fator, new.quantidade,  new.identifica_grade,&apos;A&apos;);&#010;         else&#010;           update balancoitens set (quantidade) = (quantidade+new.quantidade)  where idbalanco = new.idbalanco and local_estoque = new.local_estoque and codigoproduto = new.codigoproduto and unidade = new.unidade  and Coalesce(identifica_grade,&apos;&apos;)=Coalesce(NEW.identifica_grade,&apos;&apos;); &#010;                          &#010;         End If;&#010;      &#010;      End If;     &#010;&#010;      IF TG_OP = &apos;DELETE&apos; THEN&#010;          SELECT &#010;&#009;    into rec * &#010;&#009;  FROM &#010;&#009;    balancocontagemitens &#010;          WHERE &#010;&#009;    idbalanco=old.idbalanco AND codigoproduto=old.codigoproduto AND&#010;&#009;    identifica_grade=Old.identifica_grade AND idcontagembalanco &lt;&gt; old.idcontagembalanco;&#010;          &#010;          IF Rec Is Null Then&#010;             DELETE FROM balancoitens WHERE idbalanco = old.idbalanco AND codigoproduto=old.codigoproduto AND identifica_grade=Old.identifica_grade;&#010;          End if;   &#010;          Return OLD;&#010;      Else&#010;          Return New;    &#010;      END IF;&#010;      &#010;   END;&#010;$function$&#010;"/><ROW RowState="4" tipo="Sequence" nome="tab_boleto_layouts_instrucoesretorno_tipoinstrucaoretorno_seq" definicao="Create Sequence  tab_boleto_layouts_instrucoesretorno_tipoinstrucaoretorno_seq&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1"/><ROW RowState="4" tipo="View" nome="vercontas" definicao="Create View vercontas&#013;&#010;&#009;&#009; as &#013;&#010; SELECT contas.chave,&#010;    contas.filial,&#010;    contas.tipo,&#010;    contas.clifor,&#010;    contas.portador,&#010;    contas.vendedor,&#010;    contas.tipodoc,&#010;    contas.ctcusto,&#010;    contas.documento,&#010;    contas.prestacao,&#010;    contas.historico,&#010;    contas.dtlanc,&#010;    contas.vencimento,&#010;    contas.valordoc,&#010;    contas.pagamento,&#010;    contas.valorpago,&#010;    contas.valorsaldo,&#010;    contas.jurosnpg,&#010;    contas.baixa,&#010;    contas.chavestoq,&#010;    contas.contabil,&#010;    contas.idmovim1,&#010;    to_number(((((&apos;now&apos;::text)::date)::timestamp without time zone - (contas.vencimento)::timestamp without time zone))::text, &apos;99999&apos;::text) AS da,&#010;    contas.status,&#010;    contas.contrato,&#010;    contas.data_canc,&#010;    contas.idacordo,&#010;    contas.idcli_ctconsumo&#010;   FROM contas&#010;  WHERE (contas.data_canc IS NULL);&#013;&#010;"/><ROW RowState="4" tipo="View" nome="vs_indexes" definicao="Create View vs_indexes&#013;&#010;&#009;&#009; as &#013;&#010; SELECT c.relname AS table_name,&#010;    pg_get_indexdef(i.indexrelid, 0, true) AS column_name,&#010;    n.nspname AS schema,&#010;    (pg_size_pretty(pg_total_relation_size((c.oid)::regclass)))::character varying(15) AS total_index_size,&#010;    c2.relname AS tabela&#010;   FROM ((((pg_class c&#010;   JOIN pg_index i ON ((i.indexrelid = c.oid)))&#010;   JOIN pg_class c2 ON ((i.indrelid = c2.oid)))&#010;   LEFT JOIN pg_user u ON ((u.usesysid = c.relowner)))&#010;   LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))&#010;  WHERE ((((NOT i.indisprimary) AND (c.relkind = ANY (ARRAY[&apos;i&apos;::&quot;char&quot;, &apos;&apos;::&quot;char&quot;]))) AND (n.nspname &lt;&gt; ALL (ARRAY[&apos;pg_catalog&apos;::name, &apos;pg_toast&apos;::name]))) AND pg_table_is_visible(c.oid))&#010;  ORDER BY c.relname, pg_get_indexdef(i.indexrelid, 0, true);&#013;&#010;"/><ROW RowState="4" tipo="View" nome="vs_trigger_definicao" definicao="Create View vs_trigger_definicao&#013;&#010;&#009;&#009; as &#013;&#010; SELECT DISTINCT tr.oid,&#010;    n.nspname AS schemaname,&#010;    c.relname AS tablename,&#010;    tr.tgname AS triggername,&#010;    pr.proname AS function_name,&#010;    pg_get_function_result(pr.oid) AS &quot;Result data type&quot;,&#010;    pg_get_function_arguments(pr.oid) AS &quot;Argument data types&quot;,&#010;        CASE&#010;            WHEN pr.proisagg THEN &apos;agg&apos;::text&#010;            WHEN pr.proiswindow THEN &apos;window&apos;::text&#010;            WHEN (pr.prorettype = (&apos;trigger&apos;::regtype)::oid) THEN &apos;trigger&apos;::text&#010;            ELSE &apos;normal&apos;::text&#010;        END AS &quot;Type&quot;,&#010;        CASE&#010;            WHEN (pr.prorettype = (&apos;trigger&apos;::regtype)::oid) THEN pg_get_triggerdef(tr.oid)&#010;            ELSE NULL::text&#010;        END AS trigger_def&#010;   FROM ((((((pg_class c&#010;   JOIN pg_attribute a ON ((a.attrelid = c.oid)))&#010;   JOIN pg_type t ON ((t.oid = a.atttypid)))&#010;   LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))&#010;   LEFT JOIN pg_tablespace ts ON ((ts.oid = c.reltablespace)))&#010;   LEFT JOIN pg_trigger tr ON ((((tr.tgrelid)::regclass)::text = (&#010;CASE&#010;WHEN (n.nspname &lt;&gt; &apos;public&apos;::name) THEN ((n.nspname)::text || &apos;.&apos;::text)&#010;ELSE &apos;&apos;::text&#010;END || (c.relname)::text))))&#010;   LEFT JOIN pg_proc pr ON ((pr.oid = tr.tgfoid)))&#010;  WHERE ((((a.attnum &gt; 0) AND (NOT a.attisdropped)) AND (tr.tgisinternal IS NOT TRUE)) AND (tr.tgname IS NOT NULL))&#010;  ORDER BY n.nspname, c.relname;&#013;&#010;"/><ROW RowState="4" tipo="Sequence" nome="tab_parametrosconfiguracoes_idparametro_seq" definicao="Create Sequence  tab_parametrosconfiguracoes_idparametro_seq&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1"/><ROW RowState="4" tipo="View" nome="vs_classeprodutos" definicao="Create View vs_classeprodutos&#013;&#010;&#009;&#009; as &#013;&#010; SELECT subgrupos.classe,&#010;    grupos.descricao AS nomegrupo,&#010;    subgrupos.descricao AS nomesubgrupo,&#010;    ((((grupos.descricao)::text || &apos; - &apos;::text) || (subgrupos.descricao)::text))::character(63) AS nomeclasse,&#010;    COALESCE(subgrupos.perc_comissao, (0)::double precision) AS comisao,&#010;    COALESCE(subgrupos.descmaximo, (0)::real) AS descontomaximo&#010;   FROM (subgrupos&#010;   JOIN grupos ON ((grupos.codigo = subgrupos.grupo)));&#013;&#010;"/><ROW RowState="4" tipo="Sequence" nome="nfes_nota_idnfse_seq" definicao="Create Sequence  nfes_nota_idnfse_seq&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1"/><ROW RowState="4" tipo="View" nome="contas_relatorio" definicao="Create View contas_relatorio&#013;&#010;&#009;&#009; as &#013;&#010; SELECT contas.chave,&#010;    contas.filial,&#010;    contas.tipo,&#010;    contas.clifor,&#010;    contas.portador,&#010;    contas.vendedor,&#010;    contas.tipodoc,&#010;    contas.ctcusto,&#010;    contas.documento,&#010;    contas.prestacao,&#010;    contas.historico,&#010;    contas.dtlanc,&#010;    contas.vencimento,&#010;    contas.valordoc,&#010;    contas.pagamento,&#010;    contas.valorpago,&#010;    contas.valorsaldo,&#010;    contas.jurosnpg,&#010;    contas.baixa,&#010;    contas.chavestoq,&#010;    contas.contabil,&#010;    contas.basecomissao,&#010;    contas.contrato,&#010;    contas.idmovim1,&#010;    contas.data_canc,&#010;    contas.status,&#010;    contas.usuario_cancelou,&#010;    contas.idacordo,&#010;    contas.idnumos,&#010;    contas.idfoto_envelope,&#010;    contas.idcli_ctconsumo,&#010;    clientes.nome AS nomecliente,&#010;    vendedor.nome AS nomevendedor&#010;   FROM ((contas&#010;   LEFT JOIN clientes ON ((clientes.codigo = contas.clifor)))&#010;   LEFT JOIN vendedor ON ((vendedor.codigo = contas.vendedor)))&#010;  WHERE ((contas.tipo)::text = &apos;R&apos;::text);&#013;&#010;"/><ROW RowState="4" tipo="View" nome="ver_usuarios" definicao="Create View ver_usuarios&#013;&#010;&#009;&#009; as &#013;&#010; SELECT usuarios.usuario AS codigousuario,&#010;    usuarios.idnivel,&#010;    usuarios.senha,&#010;    usuarios.nome AS nome_usuario,&#010;    nivelacesso.nome_nivel,&#010;    nivelacesso.reabrecaixa,&#010;    nivelacesso.alteraprcvenda,&#010;    nivelacesso.liberacredito,&#010;    nivelacesso.liberadescontovenda,&#010;    nivelacesso.liberadescontobaixa,&#010;    nivelacesso.cancelarcupompdv,&#010;    nivelacesso.loja_acesso,&#010;    nivelacesso.cancelaitem_pdv,&#010;    nivelacesso.estoque_negativo,&#010;    nivelacesso.ocultarsaldocaixa&#010;   FROM (usuarios&#010;   JOIN niveisacesso nivelacesso ON ((nivelacesso.idnivel = usuarios.idnivel)));&#013;&#010;"/><ROW RowState="4" tipo="Type" nome="frame" definicao="Create type frame as &#013;&#010;&#009;&#009;(&#013;&#010;&#013;&#010;&#009;&#009;level integer  ,&#013;&#010;&#009;&#009;targetname text  ,&#013;&#010;&#009;&#009;func oid  ,&#013;&#010;&#009;&#009;linenumber integer  ,&#013;&#010;&#009;&#009;args text  &#013;&#010;&#009;&#009;)"/><ROW RowState="4" tipo="Sequence" nome="envelopes2_lancamento_seq" definicao="Create Sequence  envelopes2_lancamento_seq&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1"/><ROW RowState="4" tipo="Sequence" nome="seq_trocas" definicao="Create Sequence  seq_trocas&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 99999999999999 START 1"/><ROW RowState="4" tipo="View" nome="vs_produtos" definicao="Create View vs_produtos&#013;&#010;&#009;&#009; as &#013;&#010; SELECT cadprod.codigo,&#010;    cadprod.datacad,&#010;    cadprod.descricao,&#010;    cadprod.complemento,&#010;    cadprod.unidade,&#010;    cad_unidades.descricao_unidade,&#010;    cadprod.embalagem,&#010;    cadprod.pesolq,&#010;    cadprod.pesobr,&#010;    cadprod.classific,&#010;    cadprod.fornecedor,&#010;    cadprod.fabrica,&#010;    cadprod.codbarra,&#010;    cadprod.codbarra2,&#010;    cadprod.clfisc,&#010;    cadprod.frete,&#010;    cadprod.lucro,&#010;    cadprod.icm_dentro,&#010;    cadprod.icm_fora,&#010;    cadprod.base_icms,&#010;    cadprod.ipi_compra,&#010;    cadprod.ipi_venda,&#010;    cadprod.comissao,&#010;    cadprod.pr_venda,&#010;    cadprod.ultprcvenda,&#010;    cadprod.ult_preco,&#010;    cadprod.status,&#010;    cadprod.promocao,&#010;    cadprod.quantfracao,&#010;    cadprod.fracao,&#010;    cadprod.unidfracao,&#010;    cadprod.pr_fracao,&#010;    cadprod.idpativo,&#010;    cadprod.idfamilia,&#010;    cadprod.acresc_fracao,&#010;    cadprod.codigoguia,&#010;    cadprod.descricao_popular,&#010;    cadprod.idtabtrib,&#010;    cadprod.possui_agregados,&#010;    cadprod.tipoitem,&#010;    cadprod.ideditora,&#010;    cadprod.idassunto,&#010;    cadprod.idautor,&#010;    cadprod.cod_gen,&#010;    cadprod.med_generico,&#010;    cadprod.med_precoliberado,&#010;    cadprod.med_tipolista,&#010;    cadprod.alteradoem,&#010;    cadprod.iss,&#010;    cadprod.kit_tipopreco,&#010;    cadprod.kit_desconto,&#010;    cadprod.cod_ncm,&#010;    cadprod.idtabtrib2,&#010;    cadprod.x9,&#010;    cadprod.idgrade,&#010;    cadprod.informacoes,&#010;    cadprod.foto_arquivo,&#010;    cadprod.foto_banco,&#010;    cadprod.descvenda AS pdescmaximogeral,&#010;    estoque.produtoloja_pdescmaximo,&#010;    estoque.prccompra,&#010;    estoque.prccusto,&#010;    estoque.ultcompra,&#010;    estoque.ultvenda,&#010;    estoque.filial AS idfilial,&#010;    estoque.estreal AS estoqueloja,&#010;    estoque.estfiscal AS estoquedeposito,&#010;    estoque.minimo AS estoqueminimo,&#010;    estoque.localizacao,&#010;    fornec.nome AS nomefornec,&#010;    fabrica.descricao AS fabrica_descricao,&#010;    grupos.descricao AS grupo_descricao,&#010;    subgrupos.descricao AS subgrupo_descricao,&#010;    subgrupos.descmaximo AS subgrupo_pdescmaximo,&#010;    tab_autores.autor,&#010;    tab_editoras.editora,&#010;    tab_assunto.assunto,&#010;    tab_pativo.pativo_nome,&#010;        CASE&#010;            WHEN ((btrim((cadprod.x9)::text) IS NULL) OR (md5(((((cadprod.descricao)::text || (cadprod.pr_venda)::text) || (cadprod.idtabtrib)::text) || (COALESCE(cadprod.codbarra, &apos; &apos;::character varying))::text)) &lt;&gt; (cadprod.x9)::text)) THEN true&#010;            ELSE false&#010;        END AS cad_alterado,&#010;        CASE&#010;            WHEN ((btrim((estoque.x9)::text) IS NULL) OR (md5((((COALESCE(estoque.estreal, (0)::double precision))::text || (COALESCE(estoque.estfiscal, (0)::double precision))::text) || (COALESCE(estoque.ultvenda, (&apos;now&apos;::text)::date))::text)) &lt;&gt; (estoque.x9)::text)) THEN true&#010;            ELSE false&#010;        END AS estoque_alterado&#010;   FROM ((((((((((estoque cadprod&#010;   LEFT JOIN estoqfil estoque ON ((estoque.produto = cadprod.codigo)))&#010;   LEFT JOIN fornecedores fornec ON ((fornec.codigo = cadprod.fornecedor)))&#010;   LEFT JOIN fabricantes fabrica ON ((fabrica.codigo = cadprod.fabrica)))&#010;   LEFT JOIN subgrupos ON (((subgrupos.classe)::text = (cadprod.classific)::text)))&#010;   LEFT JOIN grupos ON ((grupos.codigo = subgrupos.grupo)))&#010;   LEFT JOIN livro_autores tab_autores ON ((tab_autores.idautor = cadprod.idautor)))&#010;   LEFT JOIN livro_editoras tab_editoras ON ((tab_editoras.ideditora = cadprod.ideditora)))&#010;   LEFT JOIN livro_assunto tab_assunto ON ((tab_assunto.idassunto = cadprod.idassunto)))&#010;   LEFT JOIN produtos_principio_ativo tab_pativo ON ((tab_pativo.idpativo = cadprod.idpativo)))&#010;   LEFT JOIN cad_unidades ON (((cad_unidades.idunidade)::text = (cadprod.unidade)::text)));&#013;&#010;"/><ROW RowState="4" tipo="Sequence" nome="tab_boleto_instrucoesremessa_idinstrucaoremessa_seq" definicao="Create Sequence  tab_boleto_instrucoesremessa_idinstrucaoremessa_seq&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1"/><ROW RowState="4" tipo="Sequence" nome="movcaixa_chave_key" definicao="Create Sequence  movcaixa_chave_key&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1854641"/><ROW RowState="4" tipo="Sequence" nome="envelopes2_lancamento_key" definicao="Create Sequence  envelopes2_lancamento_key&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1"/><ROW RowState="4" tipo="Function" nome="f_kardex(bigint, character, integer, character, date, date)" definicao="CREATE OR REPLACE FUNCTION public.f_kardex(pcodigo bigint, pgrade character, ploja integer, ptipoestoque character, pdatainicial date, pdatafinal date)&#010; RETURNS SETOF tkardex&#010; LANGUAGE plpgsql&#010;AS $function$DECLARE&#010;   REC       tkardex%rowtype; -- Variavel de retorno da funcao&#010;   rkardex   record; -- Variavel de auxilio pra percorrer kardex&#010;   rproduto  record; -- variavel de auxilio pra carregar cadastro de produto  &#010;   saldo     record; -- variavel de auxilio pra carregar saldo anterior&#010;   contagem  record; -- variaval de auxilio pra carregar contagem&#010;   dataa     DATE; -- variaval pra armazenar data anterior&#010;   _fator    INTEGER;&#010;   mov       record; -- variaval pra carregar movimento relacionado com o kardex&#010;   _mul      integer;&#010;   seq       integer;&#010;   saldoa    real;&#010;BEGIN&#010;seq := 0;&#010;saldoa := 0;&#010;--Carrega cadastro do produto&#010;select into rproduto * from estoque  where estoque.codigo = pcodigo;&#010;_fator := case when rproduto.fracao = &apos;S&apos; then rproduto.quantfracao else 1 end ; -- carrega o fator multiplicador do estoque&#010;&#010;&#010;--Carrega Kardex de acordo com os parametros passados&#010;for rkardex in Select linhas.grade_linha ||&apos;.&apos;||colunas.nomecoluna_linha as descricaograde, kardex.* from kardex &#010;                 left join grade_colunas colunas on colunas.identifica_grade=kardex.idgrade&#010;                 left join grade_linhas linhas on (linhas.idgrade_linha=colunas.idgrade_linha and linhas.idgrade=colunas.idgrade)&#010;                where  codigoloja = ploja and tipoestoque=ptipoestoque and idproduto=pcodigo and coalesce(kardex.idgrade,&apos;&apos;) = coalesce(pgrade,&apos;&apos;) and data &gt;= pdatainicial and data &lt;= pdatafinal   and codigoloja = ploja &#010;                order by kardex.data, tipo, kardex.idkardex&#009;--Routine body goes here...&#010;loop&#010;     --Carrega movimento relacionado com o kardex&#010;     Select into mov * from movim2 &#010;            Left join movim1 on ( movim1.link = movim2.link)  &#010;            Left join tipomov on  (tipomov.codigo = movim1.opcomerc ) &#010;     where &#010;        movim2.idkardex = rkardex.idkardex ; &#010;     rec.balanco= False; &#010;    -- Testa se &#233; o primeiro lancamento do dia &#010;    if coalesce(dataa,&apos;19000101&apos;) &lt;&gt; rkardex.data THEN&#010;       --Carrega saldo do dia anterior&#010;       select into saldo * from produtoposicaodiaria where tipoestoque=ptipoestoque and idproduto=pcodigo  and coalesce(idgrade,&apos;&apos;) = coalesce(pgrade,&apos;&apos;) and  data &lt; rkardex.data and codigoloja = ploja order by data desc limit 1;&#010;       if not saldo is null Then&#010;     --    saldoa := coalesce(saldo.saldo / _fator ,0);  &#010;         saldoa := coalesce(saldo.saldo,0);  &#010;     --  Else&#010;    --     saldoa := 0; &#010;       end if;&#010;       --Carrega o saldo do dia atual e ver ser teve contagem &#010;       select into contagem * from produtoposicaodiaria where tipoestoque=ptipoestoque and idproduto=pcodigo  and coalesce(idgrade,&apos;&apos;) = coalesce(pgrade,&apos;&apos;) and  data = rkardex.data  and codigoloja = ploja order by data desc limit 1;&#010;       if  not contagem is null  Then &#010;           if Coalesce(contagem.balanco,false) THEN &#010;           --   saldoa := contagem.contagem / _fator;&#010;              saldoa := contagem.contagem;&#010;              rec.balanco := contagem.balanco;&#010;           End If;             &#010;       End If;        &#010;     end if; &#010;      &#010;     --atribui os valores de retorno da linha do kardex&#010;     _mul := case when rkardex.es = &apos;S&apos; then -1 else 1 end;&#010;     REC.saldoanterior := saldoa;&#010;     REC.quantidade    := rkardex.quantidade; &#010;     if rkardex.fator &gt; 1 Then&#010;        REC.saldoatual    :=  REC.saldoanterior + ((REC.quantidade * _fator *  _mul));&#010;        REC.fator =  _fator;&#010;        REC.fracionado = False; &#010;     Else&#010;        REC.saldoatual    :=   REC.saldoanterior + (((REC.quantidade) *  _mul));&#010;        REC.fator =  1;&#010;        REC.fracionado = True; &#010;     End If;&#010;      &#010;     seq := 1;&#010;     dataa := rkardex.data;&#010;     saldoa := REC.saldoatual; &#010;     rec.data = rkardex.data; &#010;     rec.codigo = rkardex.idproduto; &#010;     rec.grade  = rkardex.idgrade; &#010;     rec.unidademovimentada = rkardex.unidade; &#010;     REC.unidadepadrao = rproduto.unidade;&#010;     &#010;     REC.descricao = rproduto.descricao;&#010;     REC.descricaograde = rkardex.descricaograde;&#010;     REC.tipomovimentacao = rkardex.es;&#010;     REC.operacaocomercial = mov.opcomerc;&#010;&#010;     IF mov.descricao&lt;&gt;&apos;&apos; THEN&#010;        REC.descricaomovimentacao =  mov.descricao;&#010;     ELSE&#010;        REC.descricaomovimentacao =  rkardex.descricao;&#010;     END IF;   &#010;     &#010;     --REC.descricaomovimentacao :=  mov.descricao; &#010;     if rkardex.tipo = &apos;I&apos; THEN&#010;        rec.descricaomovimentacao = &apos;Kardex Inicial &apos;; &#010;     End If;&#010;     rec.nota := mov.documento;&#010;  &#010;  &#010;     --Retorna linha do kardex   &#010;    return Next rec;&#010;end loop;&#010;&#010;END&#010;$function$&#010;"/><ROW RowState="4" tipo="Sequence" nome="pedido2_chave_key" definicao="Create Sequence  pedido2_chave_key&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1"/><ROW RowState="4" tipo="Type" nome="breakpoint" definicao="Create type breakpoint as &#013;&#010;&#009;&#009;(&#013;&#010;&#013;&#010;&#009;&#009;func oid  ,&#013;&#010;&#009;&#009;linenumber integer  ,&#013;&#010;&#009;&#009;targetname text  &#013;&#010;&#009;&#009;)"/><ROW RowState="4" tipo="Sequence" nome="tab_infotef_idinfo_tef_key" definicao="Create Sequence  tab_infotef_idinfo_tef_key&#013;&#010; INCREMENT 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1"/><ROW RowState="4" tipo="View" nome="vs_constraint" definicao="Create View vs_constraint&#013;&#010;&#009;&#009; as &#013;&#010; SELECT ct.constraint_schema,&#010;    r.conname,&#010;    ct.table_name,&#010;    pg_get_constraintdef(r.oid, true) AS condef,&#010;    ct.constraint_type&#010;   FROM (information_schema.table_constraints ct&#010;   LEFT JOIN pg_constraint r ON ((r.conname = (ct.constraint_name)::name)))&#010;  WHERE (((ct.constraint_schema)::name = &quot;current_schema&quot;()) AND ((ct.constraint_type)::text = ANY (ARRAY[(&apos;UNIQUE&apos;::character varying)::text, (&apos;PRIMARY KEY&apos;::character varying)::text, (&apos;FOREIGN KEY&apos;::character varying)::text])));&#013;&#010;"/><ROW RowState="4" tipo="View" nome="atributos_colunas" definicao="Create View atributos_colunas&#013;&#010;&#009;&#009; as &#013;&#010; SELECT a.attrelid AS idobjeto,&#010;    a.attname AS nomecoluna,&#010;    format_type(a.atttypid, a.atttypmod) AS formato,&#010;    ( SELECT &quot;substring&quot;(d.adsrc, 1, 128) AS &quot;substring&quot;&#010;           FROM pg_attrdef d&#010;          WHERE (((d.adrelid = a.attrelid) AND (d.adnum = a.attnum)) AND a.atthasdef)) AS valordefault,&#010;    (NOT a.attnotnull) AS aceitanulo,&#010;    a.attnum&#010;   FROM pg_attribute a&#010;  WHERE ((a.attnum &gt; 0) AND (format_type(a.atttypid, a.atttypmod) &lt;&gt; &apos;-&apos;::text));&#013;&#010;"/></ROWDATA></DATAPACKET>